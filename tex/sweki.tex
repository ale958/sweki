\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,italian]{babel}
\usepackage{microtype}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{csquotes}
\setcounter{section}{-1}
\title{sweki}
\author{Giorgio Giuffrè}
\date{}

\begin{document}
\maketitle
\tableofcontents
\newpage


\section{Sommario}
sweki è un progetto che raccoglie i miei appunti dal corso di Ingegneria del Software tenuto dal prof. Tullio Vardanega nell'anno accademico 2016-2017. Gli appunti sono presi un po' dalle lezioni del professore e un po' dal materiale riportato in bibliografia.

Gli appunti sono disponibili su GitHub all'indirizzo \url{https://github.com/FIUP/sweki} in tre formati:
\begin{itemize}
	\item .html --- \url{https://github.com/FIUP/sweki};
	\item .tex --- \url{https://github.com/FIUP/sweki/tex/sweki.tex};
	\item .pdf --- qui.
\end{itemize}

la versione in \LaTeX{} è derivata automaticamente da quella in XHTML tramite dei template XSLT e dei terribili script di shell (bash).



		
	\section{Introduzione all'ingegneria del software}


		
	\subsection{Cos'è l'ingegneria del software?}

		
Mentre la scienza è un insieme di princìpi interpretativi della realtà, l'\textbf{ingegneria} è un'\emph{applicazione} della scienza alla realtà (magari in modo originale, ingegnoso). Quindi l'ingegneria non crea nuova conoscenza, come invece fa la scienza. Il termine \textbf{software}, invece, si compone di due parti: ware significa "cosa inerte", oggetto; soft aggiunge una connotazione astratta, dato che il software non è altro che una costruzione del pensiero. L'ingegneria del software è l'applicazione dell'ingegneria al software, cioè l'applicazione di un approccio \textbf{sistematico}, \textbf{disciplinato} e \textbf{quantificabile} allo sviluppo, al funzionamento e al mantenimento del software. Sistematico nel senso che abbraccia un metodo; disciplinato poiché segue delle norme, anzi la best practice; quantificabile poiché si deve sapere a priori quanto si consumerà (in risorse). Le ingegnerie dell'hardware, del software e dei processi sono specializzazioni dell'ingegneria dei sistemi.

		
	\subsection{Cosa \emph{non} è l'ingegneria del software?}

		
L'ingegneria del software (d'ora in avanti "IS") non è un ramo dell'informatica; è una disciplina ingegneristica che fa affidamento solo in parte sull'informatica, allo stesso modo in cui l'ingegneria meccanica fa affidamento sulla fisica.

		
	\subsection{Software}

		
Per software s'intende il programma con la sua documentazione. A causa dell'assenza di vincoli fisici, il software ha un potenziale illimitato; tuttavia, per lo stesso motivo, esso può velocemente diventare complesso, difficile da capire e costoso da cambiare. Difatti, l'IS si confronta con progetti così impegnativi da richiedere necessariamente un lavoro di gruppo.

		
	\subsection{Efficacia ed efficienza}

		
I prodotti software devono presentare due qualità: \textbf{efficacia} (conformità alle attese) ed \textbf{efficienza} (contenimento dei costi per raggiungere un obiettivo). L'efficienza ha a che fare soprattutto con i bisogni e le risorse\footnote{Risorse: persone, tempo, denaro e materiale.}; l'efficacia, invece, riguarda il prodotto finale. Tuttavia i due termini confliggono: l'efficacia sottintende il verbo "fare", mentre la massima efficienza è proprio il non fare nulla! Bisogna dunque badare a trovare un compromesso, possibilmente in modo sistematico. Ma sappiamo che esiste un ciclo virtuoso tra sistematizzazione ed esperienza. Ecco allora che si ricorre alla best practice, la prassi che per esperienza e per studio abbia mostrato di garantire i migliori risultati in circostanze note e specifiche.

		
	\subsection{Come studiare}

		
Due sono i tipi di libri su cui si può studiare: i \textbf{libri teorici} espongono i princìpi ma non l'esperienza concreta; i \textbf{libri esperienziali} fanno l'opposto e servono soprattutto per risolvere dubbi. ingegneria del software va capita studiando con entrambi questi tipi di libri e, soprattutto, partecipando al \textbf{progetto didattico}. Inoltre, torna molto utile compilare un proprio \textbf{glossario} dei termini.
	


		
	\section{Processi software}


		
	\subsection{Definizione}

		
In ingegneria, secondo l'ISO, un \textbf{processo} è un insieme di attività correlate e coese che trasformano ingressi in uscite, consumando risorse nel farlo. In particolare, un processo software (d'ora in avanti solo "processo") porta ad un \emph{prodotto} software.

		
	\subsection{Anatomia}

		
Ogni processo si divide in più \textbf{attività}. Ogni attività si divide in \textbf{compiti}. Ogni compito si può svolgere usando qualche tecnica, cioè una sorta di ricetta applicata agli strumenti disponibili. Per strumento s'intende un insieme di concetti e di metodi, con delle tecnologie di supporto.

		
	\subsection{Processi software, aziende e progetti}

		
Distinguiamo le seguenti tre categorie principali di processi:
		
	\begin{itemize}
		
			
	\item standard di processo --- riferimento di base generico usato come stile comune per lo svolgimento delle funzioni aziendali, pensato per una collettività di casi afferenti ad un certo dominio applicativo (quindi una sorta di template); % "processo standard" o std di processo? forse da process standard, in inglese

			
	\item processo definito --- specializzazione dello standard di processo necessaria per adattarlo ad esigenze specifiche di progetto;
			
	\item processo di progetto --- istanza di un processo definito che utilizza risorse aziendali per raggiungere obbiettivi prefissati (il processo viene calato nella realtà aziendale).
		
	\end{itemize}

		
L'organizzazione aziendale si struttura verticalmente in settori (orientati alla specializzazione) e orizzontalmente in processi (che abbracciano più settori specializzati).
		
Esiste il processo perfetto? Esiste l'insieme ideale di processi? No: nessun progetto è identico a un altro, quindi i processi vanno selezionati e adattati in modo critico, in base al progetto e/o all'organizzazione a cui servono. Selezionare, adattare, applicare e migliorare (evolvere) i processi è compito degli amministratori di progetto.
		
I processi software, di per sé, non seguono un ordinamento. Le relazioni temporali tra essi sono fornite da un modello di ciclo di vita.

		
	\subsection{ISO/IEC 12207}

		
Lo standard ISO/IEC 12207 è il più noto standard di processo. Esso divide i processi in tre famiglie.
		
	\begin{itemize}
		
			
	\item \textbf{Processi primari}:
				
	\begin{itemize}
		
					
	\item acquisizione (gestione dei propri sotto-fornitori\footnote{Gli acquirenti di software non sono solo utenti "laici" ma anche (e soprattutto) altre case di software: il maggior acquirente di software è Google!}, cioè di chi ci fornisce una componente del nostro prodotto);
					
	\item fornitura (gestione dei rapporti con il cliente --- controparte dell'acquisizione);
					
	\item sviluppo --- affrontato con approccio costruttivo, non correttivo; svolto anche tramite appalto esterno; \emph{non} solo programmazione (che tra l'altro va affiancata dal testing)!
					
	\item gestione operativa (installazione ed erogazione dei prodotti);
					
	\item manutenzione (correzione, adattamento, evoluzione).
				
	\end{itemize}

			
			
	\item \textbf{Processi di supporto} (delle specie di "sottoprocedure"):
				
	\begin{itemize}
		
					
	\item documentazione;
					
	\item gestione delle versioni e della configurazione;
					
	\item accertamento della qualità;
					
	\item qualifica: verifica e validazione ("V\&{}V"), due processi distinti ma collegati;
					
	\item revisioni congiunte con il cliente;
					
	\item verifiche ispettive esterne;
					
	\item risoluzione dei problemi.
				
	\end{itemize}

			
			
	\item \textbf{Processi organizzativi} (l'"ambiente" del sistema):
				
	\begin{itemize}
		
					
	\item gestione dei processi;
					
	\item gestione delle infrastrutture;
					
	\item miglioramento del processo;
					
	\item formazione del personale.
				
	\end{itemize}

			
		
	\end{itemize}

		
Un ingegnere del software sa fare qualsiasi processo tra i suddetti.

		
	\subsection{Organizzazione di processo}

		
Per essere disciplinati si ha bisogno di una forma di standardizzazione, per "tenere alta" la qualità di un lavoro ripetitivo che rischia continuamente di degradare. Ecco perché un buon processo si auto-migliora, in modo continuo, secondo lo \textbf{schema PDCA} (ciclo di Deming):
		
	\begin{enumerate}
		
			
	\item Plan: individuare obiettivi di miglioramento.
			
	\item Do: eseguire ciò che si è pianificato.
			
	\item Check: verificare se ha funzionato. Non è tanto un'ispezione quanto, piuttosto, un'analisi\footnote{Deming preferiva infatti la sigla PDSA: Plan, Do Study, Act.}; si studiano i risultati della fase precedente (do) e li si cofrontano con gli obiettivi individuati nella prima fase (plan).
			
	\item Act: agire per correggersi. Se la fase precedente (check) ha dimostrato che il piano (plan) implementato (do) è migliore rispetto agli standard precedenti, allora questo piano diventa il nuovo standard --- la nuova \emph{baseline}. Altrimenti, il vecchio standard in uso rimarrà la \emph{baseline}.
		
	\end{enumerate}


		
	\subsection{Efficienza ed efficacia di un processo}

		
Un buon esempio di valutazione dell'efficienza e dell'efficacia è la misurazione di questi due aspetti a livello di processo. Efficienza di un processo, attività o compito è il rapporto tra le \textbf{risorse} realmente consumate e quelle che si era previsto venissero consumate; efficacia di un processo, attività o compito è il rapporto tra i \textbf{prodotti} realmente ottenuti a partire dal processo e i prodotti che si volevano ottenere.
	


		
	\section{Ciclo di vita del software}


		
	\subsection{Definizione}

		
Caratteristico di un prodotto di IS è il suo ciclo di vita, cioè l'insieme degli \textbf{stati} che il prodotto assume dal concepimento al ritiro\footnote{Per ritiro s'intende il momento in cui il prodotto cessa di essere seguito dai creatori.}. Senza di esso non esisterebbe la figura dell'ingegnere del software. Conviene vedere il ciclo di vita come una macchina a stati, in cui gli stati sono il grado di maturazione del prodotto e gli archi rappresentano attività (suddivise in processi) che servono a far avanzare il prodotto nel suo grado di maturazione. La durata temporale entro uno stato del ciclo di vita e un altro è detta \textbf{fase}. Misura del successo di un prodotto è un ciclo di vita lungo, speso per lo più in manutenzione, magari con un buon feedback da parte degli utenti. Distinguiamo tre tipi di manutenzione:
		
	\begin{itemize}
		
			
	\item correttiva  \texttt{:(}  per correggere difetti;
			
	\item di adattamento  \texttt{:|}  per adattare il sistema a variazioni di requisiti;
			
	\item evolutiva  \texttt{;)}  per aggiungere funzionalità al sistema.
		
	\end{itemize}

		
Esempio di manutenzione evolutiva è Firefox.

		
	\subsection{Modelli di ciclo di vita}

		
I processi software, di per sé, non seguono un ordinamento; le relazioni temporali e logiche tra essi sono fornite da un \textbf{modello} di ciclo di vita. Esistono diversi possibili cicli di vita, che si distinguono non per numero o significato degli stati, bensì per le transizioni tra essi e le loro regole di attivazione. Alcuni modelli di ciclo di vita sono:
		
	\begin{itemize}
		
			
	\item sequenziale --- tipo catena di montaggio;
			
	\item incrementale --- realizzazione in più passi, con numero crescente di funzionalità;
			
	\item evolutivo --- con ripetute iterazioni interne;
			
	\item a spirale --- contesto allargato e modello astratto;
			
	\item agile --- dinamico, a cicli iterativi e incrementali.
		
	\end{itemize}

		
È bene tenere a mente che i vari modelli, per quanto differiscano tra di loro in questo o in quel dettaglio, si possono dividere in due grandi famiglie: quelli sequenziali e quelli iterativi; i modelli incrementale, evolutivo, a spirale e agile sono tutti esempi di modelli iterativi.
		
In genere un modello del ciclo di vita di un \emph{prodotto}\footnote{SPLC, Software Product Life Cycle.} include un modello del ciclo di vita dello \emph{sviluppo}\footnote{SDLC, Software Development Life Cycle.} (più eventuali altri processi che riguardano fornitura, manutenzione, evoluzione...). Attenzione: il ciclo di vita dello sviluppo non deve per forza seguire lo stesso modello del ciclo di vita dell'intero prodotto!
		
Tra le qualità che contraddistinguono l'IS --- sistematicità, disciplina, quantificabilità --- i modelli di ciclo di vita nascono con l'obiettivo di perseguire la \textbf{quantificabilità}, che è la più difficile da soddisfare.

		
	\subsection{Il modello sequenziale}

		
Nel 1970, grazie a Winston Royce, venne ideato il modello sequenziale (o a cascata), ispirato alle catene di montaggio. Questo è una successione di \textbf{fasi} rigidamente sequenziali. Il modello originale prevede che non si possa mai essere in due stati diversi allo stesso tempo e che non si possa tornare ad uno stato precedente. Il passaggio da una fase alla successiva è basato sulla documentazione: ogni fase produce documenti che la concretizzano e devono essere approvati per il passaggio alla fase successiva. Nello specifico, ogni fase viene definita in termini di:
		
	\begin{itemize}
		
			
	\item attività previste;
			
	\item prodotti attesi in ingresso;
			
	\item prodotti attesi in uscita;
			
	\item ruoli coinvolti;
			
	\item scadenze di consegna.
		
	\end{itemize}

		
Questo modello ha il pregio di individuare fasi distinte e ordinate nelle quali decomporre il progetto. Suo difetto principale è l'eccessiva \textbf{rigidità}. Tuttavia questo approccio può funzionare se il cliente è consapevole (e abbastanza sicuro) di ciò che vuole, pur tenendo conto che il modello genera software vero e proprio molto tardi nel ciclo di vita.
		
Allora, si pensò di correggere il modello creando un "ibrido", introducendo dei prototipi "usa e getta" oppure la possibilità di tornare ad uno stato precedente. Tuttavia risalire la cascata fa risalire il progetto nel tempo e genera iterazioni, non incrementi.

		
	\subsection{Il modello incrementale}

		
Per superare le difficoltà del modello sequenziale ibrido, nacque il modello incrementale: in esso, i cicli non sono più iterazioni ma \textbf{incrementi} --- con l'eccezione dell'analisi e della progettazione, che si affrontano all'inizio e non vengono ripetute. Il modello prevede rilasci multipli e successivi; ciascuno realizza un incremento di funzionalità, approssimando sempre meglio la soluzione. Un grande vantaggio è che le funzionalità più importanti vengono affrontante all'inizio. Questo modello è meno idealista ma più gentile.

		
	\subsection{Il modello evolutivo}

		
Il modello evolutivo, che è incrementale, prevede che gli incrementi successivi siano versioni (prototipi) usabili dal cliente. Più versioni posso essere mantenute in parallelo e ogni fase ammette iterazioni multiple. % ??


		
	\subsection{Il modello a spirale}

		
Nel 1988 Barry Boehm propose il modello a spirale, che introduce il concetto di "rischio di progetto" (cercando di contenere tali rischi). Lo sviluppo procede a cicli sempre più lenti; difatti i cicli esterni sono così lenti che possono aderire, ognuno, ad un altro modello di ciclo di vita. Ad ogni ciclo si analizzano i rischi e si compiono simulazioni. Misura del successo di un progetto è il diametro della spirale. Questo modello viene usato solo da chi intraprende progetti sperimentali, che nessuno ha mai realizzato, e richiede forte interazione tra committente e fornitore. Un ciclo si articola generalmente in quattro momenti:
		
	\begin{enumerate}
		
			
	\item definizione degli obiettivi;
			
	\item analisi dei rischi;
			
	\item sviluppo e validazione;
			
	\item pianificazione della successiva iterazione.
		
	\end{enumerate}


		
	\subsection{Il modello a componenti}

		
Più pragmatico è il modello a componenti, che prevede l'integrazione di componenti già implementati. L'idea nasce dal fatto che molto di quel che ci serve fare è già stato fatto e molto di quel che faremo ci potrà servire ancora. Difatti, l'IS è un insieme di best practices che assembla componenti già esistenti, più che crearle ex novo.

		
	\subsection{I metodi agili}

		
I metodi agili nascono alla fine degli anni '90 come reazione all'eccessiva rigidità dei modelli allora in vigore. Si basano su quattro princìpi:
		
	\begin{itemize}
		
			
	\item individuals and interactions over processes and tools;
			
	\item working software over comprehensive documentation;
			
	\item customer collaboration over contract negotiation;
			
	\item responding to change over following a plan.
		
	\end{itemize}

	


		
	\section{Gestione di progetto}


		
	\subsection{Progetto}

		
Un progetto è un insieme di \textbf{compiti} da svolgere a fronte di un assignement. Alcune \textbf{attività} (intese come insiemi di compiti) possono essere svolte individualmente ma il progetto è sempre collaborativo. Tutti i compiti sono pianificati dall'inizio alla fine, secondo specifici obiettivi e vincoli; i vincoli sono dati dal tempo disponibile, le risorse utilizzabili e i risultati attesi.

		
	\subsection{Responsabile di progetto}

		
La gestione di un progetto è compito del \textbf{responsabile di progetto}\footnote{Project manager.} e consiste di:
		
	\begin{itemize}
		
			
	\item istanziare processi nel progetto;
			
	\item stimare i costi e le risorse necessarie;
			
	\item pianificare le attività e assegnarle alle persone;
			
	\item controllare le attività e verificare i risultati.
		
	\end{itemize}


		
	\subsection{Ruoli}

		
Ogni persona, in un progetto, ha un ruolo (o funzione, in azienda\footnote{Funzione aziendale, in organizzazioni molto strutturate, con progetti simili; ruolo di progetto, in strutture con ambiti eterogenei.}). Il ruolo può essere di quattro tipi:
		
	\begin{itemize}
		
			
	\item sviluppo (responsabilità tecnica e realizzativa);
			
	\item direzione (responsabilità decisionale);
			
	\item amministrazione (gestione dei processi);
			
	\item qualità (gestione della qualità).
		
	\end{itemize}

		
Allocare le risorse per un progetto significa assegnare attività a ruoli e ruoli a persone.

		
	\subsection{Profilo professionale}

		
Ogni persona ha un profilo professionale, cioè un insieme di competenze (tecnologiche e metodologiche) e un'esperienza (espressa in anni e partecipazione a progetti) che fanno da requisiti per l'assunzione di un ruolo in un progetto. Esistono vari profili professionali.
		
	\begin{itemize}
		
			
	\item \textbf{Analista} --- a partire dal bisogno del cliente, individua il problema (di cui conosce il dominio) da fornire al progettista; solitamente non segue il progetto fino alla fine. In un certo senso, l'analista è la giuntura che collega gli utenti agli sviluppatori.
			
	\item \textbf{Progettista} --- ha competenze tecniche e tecnologiche\footnote{Mentre tecnica è il modo con cui si usa uno strumento, tecnologia è lo strumento sul quale si opera.} aggiornate e ha vasta esperienza professionale; a partire dalle specifiche del problema fornitogli, sviluppa una soluzione e rimane finché la soluzione non è stata implementata; spesso si assume la responsabilità di gestione del progetto.
			
	\item \textbf{Programmatore} --- implementa (una parte de) la soluzione del progettista; sta a lungo nel progetto poiché può essere coinvolto nella manutenzione. Ha competenze specifiche; visione e responsabilità circoscritte.
			
	\item \textbf{Verificatore} --- verifica il lavoro prodotto dai programmatori.
			
	\item \textbf{Responsabile di progetto} --- pianifica il progetto, assegna le persone ai ruoli giusti e rappresenta il progetto presso il fornitore e il committente.
			
	\item \textbf{Amministratore di progetto} --- ruolo "orizzontale": deve controllare che ad ogni istante della vita del progetto le risorse (umane, materiali, economiche e strutturali) siano presenti e operanti; inoltre, gestisce la documentazione e controlla il versionamento e la configurazione.
			
	\item \textbf{Controllore della qualità} --- funzione aziendale (e non ruolo di progetto) che accerta la qualità dei prodotti.
		
	\end{itemize}


		
	\subsection{Pianificazione di progetto}

		
Il ruolo più importante del responsabile di progetto è quello di pianificare. La pianificazione è l'identificazione del da farsi e di come farlo. È bene notare come lo stato di avanzamento di un prodotto sia rilevante solo se dà informazioni sulla pianificazione. Tre strumenti notevoli per la pianificazione di un progetto sono:
		
	\begin{itemize}
		
			
	\item I diagrammi WBS (Work Breakdown Structure) decompongono, in modo gerarchico, le attività in sottoattività; pur essendo fortemente coese, le sottoattività non sono necessariamente sequenziali.
			
	\item I diagrammi di Gantt sono ideali per rappresentare la durata, la sequenzialità e il parallelismo; si possono confrontare facilmente le stime con i progressi effettivi. Tuttavia, non sono particolarmente adatti per rappresentare le dipendenze tra attività.
			
	\item I diagrammi PERT (Project Evaluation and Review Technique) unificano le due tecniche precedenti e sono ideali per rappresentare le dipendenze temporali (e le criticità\footnote{Distanze troppo brevi tra attività dipendenti}) tra attività e, quindi, per ragionare sulle scadenze del progetto. Un tale diagramma è un grafo orientato dove gli archi rappresentano le attività, mentre i nodi sono degli eventi. Ogni evento ha una data minima a partire da cui può accadere e una data massima oltre la quale esso ritarda gli eventi successivi; la differenza tra questi due tempi è detta \emph{slack time}\footnote{Lo slack time è quindi la quantità di tempo di cui un evento può essere procrastinato senza influenzare l'andamento del progetto.}.
		
	\end{itemize}

		
Il primo passo da fare nel gestire un progetto dovrebbe essere la selezione di un modello di ciclo di vita per lo sviluppo del prodotto.

		
	\subsection{Stima dei costi di progetto}

		
Un'altro compito importante del responsabile di progetto è quello di stimarne i costi. In particolare, il responsabile deve stimare il tempo/persona\footnote{Generalmente mesi/persona, o anche settimane/persona.}, unità di misura delle risorse umane. In questo, utile \emph{caveat} è la legge di Parkinson, una critica alla regolamentazione fine a se stessa: \textquote{Work expands to fill the time available}. Uno strumento per la stima del tempo/persona è CoCoMo (Constructive Cost Model), una funzione matematica che produce in uscita un valore in tempo/persona e prende in ingresso alcuni parametri relativi al progetto; tale funzione matematica è $x = C \cdot{} D^{S} \cdot{} M$, dove $x$ è misurato in mesi-persona e i parametri sono:
		
	\begin{itemize}
		
			
	\item fattore di complessità del progetto $C$;
			
	\item misura in KDSI\footnote{Kilo Delivered Source Instructions.} della dimensione stimata del prodotto software $D$;
			
	\item fattore di complessità $S$;
			
	\item moltiplicatori di costo $M$.
		
	\end{itemize}


		
	\subsection{Rischi di progetto}

		
I risultati di un progetto software possono portare costi eccessivi, non rispettare le scadenze o risultare insoddisfacenti. Un buon metodo per gestire i rischi è il seguente:
		
	\begin{enumerate}
		
			
	\item identificazione dei rischi;
			
	\item analisi dei rischi (per ordinarli secondo una priorità);
			
	\item pianificazione di come evitare i rischi;
			
	\item monitoraggio dei rischi e, eventualmente, ritorno al punto 2 per aggiornare le strategie.
		
	\end{enumerate}

	


		
	\section{Amministrazione di progetto}


		
	\subsection{Amministratore di progetto}

		
Scopo dell'amministrare un progetto è quello di evitare conflitti che si manifestano quando ci sono sovrapposizioni di ruoli e di responsabilità. L'amministratore di un progetto\footnote{Project administrator, da non confondere con il project manager: il primo è sottoposto al secondo.} non dirige (non compie scelte gestionali) ma deve far sì che l'\textbf{infrastruttura} di lavoro sia operante; attua le scelte tecnologiche concordate con i responsabili aziendali e di progetto e si assicura che vengano seguite dai membri del progetto.

		
	\subsection{Documentazione di progetto}

		
Uno dei compiti dell'amministratore di progetto è quello di gestire la documentazione. I documenti devono essere chiaramente identificati, corretti nei contenuti, verificati, approvati, aggiornati (specificandone la data) e dotati di versione. La loro diffusione dev'essere controllata: i destinatari devono essere chiaramente identificati e ogni documento ha una sua lista di distribuzione (oppure è pubblico). La documentazione raccoglie \textbf{tutto ciò che documenta le attività} e si divide nelle seguenti due categorie.
		
	\begin{itemize}
		
			
	\item Documentazione di sviluppo:
				
	\begin{itemize}
		
					
	\item documentazione fornita dal cliente;
					
	\item diagrammi di progettazione;
					
	\item codice;
					
	\item piani di qualifica e risultati delle prove;
					
	\item documentazione di accompagnamento del progetto.
				
	\end{itemize}

			
			
	\item Documentazione di gestione del progetto:
				
	\begin{itemize}
		
					
	\item documenti contrattuali;
					
	\item piani e consuntivi delle attività;
					
	\item piani di qualità.
				
	\end{itemize}

			
		
	\end{itemize}

		
Ogni documento contiene un "diario delle modifiche", in cui vengono riportate tutte le modifiche rispetto alla versione precedente del documento. Lo stile del diario delle modifiche dev'essere molto sintetico e, a questo scopo, è bene che si avvalga di riferimenti numerici all'interno del testo (numero della sezione modificata, ad esempio).

		
	\subsection{Ambiente di lavoro}

		
L'amministratore di progetto si occupa dell'ambiente di lavoro, cioè l'insieme di persone, di ruoli, di procedure e l'infrastruttura\footnote{Tutte le risorse hardware e software del progetto.} la cui qualità determina la produttività del progetto. L'ambiente di lavoro dev'essere:
		
	\begin{itemize}
		
			
	\item completo (offre tutto il necessario per svolgere le attività previste);
			
	\item ordinato (è facile trovare ciò che vi si cerca);
			
	\item aggiornato (il materiale obsoleto non deve causare intralcio).
		
	\end{itemize}


		
	\subsection{Configurazione e versionamento di un prodotto}

		
Oltre all'aspetto temporale (cioè il ciclo di vita), ogni prodotto ha anche un aspetto più "spaziale", in quanto si compone di parti. Quali esse sono e il modo in cui stanno assieme è detto "configurazione". E ogni sistema composto di parti va gestito con:
		
	\begin{itemize}
		
			
	\item controllo di configurazione;
			
	\item controllo di versione (versione non del prodotto ma di ogni \emph{parte} della configurazione del prodotto).
		
	\end{itemize}

		
Data la complessità di un prodotto software, la gestione della configurazione va automatizzata con strumenti adatti. Ogni parte della configurazione (configuration item, CI) dev'essere univocamente identificato (oltre ad avere nome, data, autore, registro delle modifiche e stato corrente). Due concetti centrali della gestione di configurazione sono i seguenti.
		
	\begin{itemize}
		
			
	\item Quello di \textbf{\emph{baseline}} indica un punto d'arrivo tecnico dal quale non si retrocede; la \emph{baseline} è fatta di elementi della configurazione e, poiché ogni parte è versionata, possiamo conoscere la differenza tra una \emph{baseline} e l'altra. Una \emph{baseline} è qualcosa di stabile --- non usa e getta! --- e sta in un repository\footnote{Base di dati centralizzata nella quale risiedono (individualmente) tutti i CI di ogni baseline nella loro storia completa.}; serve da base per gli avanzamenti futuri e può essere cambiata solo tramite procedure di controllo di cambiamento.
			
	\item Il concetto di \textbf{milestone} indica un punto nel tempo associato ad un valore strategico. Ogni milestone di calendario è associata a uno specifico insieme di \emph{baseline}. Ogni milestone dev'essere: specifica, raggiungibile, misurabile (per quantità d'impegno necessario), traducibile in compiti assegnabili e dimostrabile agli \emph{stakeholder}\footnote{Uno stakeholder è una persona a vario titolo coinvolta nel ciclo di vita di un software, che ha influenza sul prodotto o sul processo.}.
		
	\end{itemize}

		
Anche il controllo di versione fa affidamento sul repository, per permettere di lavorare su vecchi e nuovi CI senza rischio di sovrascritture accidentali, di condividere il lavorato nello spazio comune e di poter verificare la bontà di ogni modifica di \emph{baseline}. Ogni versione è una istanza di prodotto funzionalmente distinta dalle altre. Invece, si dice "variante" una istanza di prodotto funzionalmente identica ad altre ma diversa per caratteristiche non funzionali. Infine, si dice "rilascio" (\emph{release}) una istanza di prodotto resa disponibile a utenti esterni.

		
	\subsection{Modifiche}

		
Anche nel corso del suo sviluppo, un progetto non è esente da richieste di modifiche (dagli utenti, dagli sviluppatori o semplicemente per competizione). Le richieste di modifica vanno sottoposte a un rigoroso processo di analisi, decisione, realizzazione e verifica; di ogni richiesta va tenuta traccia.

		
	\subsection{Norme di progetto}

		
Un progetto necessita di linee guida per le attività di sviluppo. Le norme --- che vanno accertate dagli amministratori --- comprendono:
		
	\begin{itemize}
		
			
	\item organizzazione e uso delle risorse di sviluppo;
			
	\item convenzioni sull'uso degli strumenti di sviluppo;
			
	\item organizzazione della comunicazione e della cooperazione;
			
	\item norme di codifica;
			
	\item gestione dei cambiamenti.
		
	\end{itemize}

		
Le norme di progetto descrivono come dovrà essere il \textbf{\emph{way of working}}. Individuiamo due categorie di norme: regole (sottoposte a verifica) e raccomandazioni (suggerimenti, senza verifica). Tra le norme di progetto, particolare rilevanza hanno le norme di codifica; queste hanno l'obiettivo di far sì che il codice sorgente sia leggibile (anche a distanza di tempo) e costituiscono una misura preventiva che garantisce verificabilità, manutenibilità e portabilità.
	


		
	\section{Ingegneria dei requisiti}


		
	\subsection{Requisito}

		
I requisiti di un sistema sono le descrizioni di cosa il sistema deve fare, cioè i servizi che offre e i vincoli sul suo funzionamento. Due definizioni un po' più formali sono:
		
	\begin{itemize}
		
			
	\item ponendoci dal punto di vista del bisogno, requisito è una condizione necessaria a un utente per risolvere un problema o raggiungere un obiettivo;
			
	\item dal punto di vista della soluzione, invece, requisito è una condizione che dev'essere soddisfatta da un sistema per adempiere a un obbligo.
		
	\end{itemize}

		
I requisiti hanno a che vedere con il processo di sviluppo del software; tuttavia la loro gestione è qualcosa di costante, che viene iterato lungo \emph{tutto} il ciclo di vita di un progetto.

		
	\subsection{Requisiti utente e di sistema}

		
"Requisito" è un termine leggermente ambiguo, in quanto viene usato per indicare sia una richiesta generale (astratta, di alto livello) sia una definizione formale e dettagliata di una funzione del sistema. È bene separare questi differenti livelli di descrizione; per questo, distinguiamo tra requisiti utente (di alto livello) e requisiti di sistema (più dettagliati).

		
	\subsection{Requisiti di prodotto e di processo}

		
È bene anche distinguere tra requisiti di prodotto (dei bisogni o dei vincoli sul software da sviluppare) e requisiti di processo (dei vincoli sullo sviluppo del software).

		
	\subsection{Requisiti funzionali e non}

		
Un'ulteriore distinzione viene fatta tra:
		
	\begin{itemize}
		
			
	\item requisiti funzionali --- i servizi che il sistema deve fornire (cioè la sua interfaccia);
			
	\item requisiti non funzionali --- i \emph{vincoli} sui servizi che il sistema fornisce (requisiti su prestazioni, manutenibilità, sicurezza, affidabilità...).
		
	\end{itemize}

		
Ma tale distinzione non è sempre netta: ad esempio, il requisito di limitare l'accesso ai soli utenti autorizzati (apparentemente non funzionale) può essere sviluppato più in dettaglio fino a richiedere un servizio di autenticazione (requisito chiaramente funzionale)!

		
	\subsection{Piano di qualifica}

		
Per garantire il rispetto dei requisiti entra in gioco il piano di qualifica, che consiste nel definire le strategie di \textbf{verifica} e scegliere metodi, tecniche e procedure da usare per la \textbf{validazione}; ha quindi a che fare con due processi:
		
	\begin{itemize}
		
			
	\item Verifica: accertare che l'esecuzione delle attività di processo non abbia introdotto errori (\textquote{Did I build the system right?}); rivolta ai processi (e svolta sui loro prodotti), per accertare il rispetto di norme e procedure.
			
	\item Validazione: accertare che il prodotto realizzato corrisponda alle attese (\textquote{Did I build the right system?}); rivolta ai prodotti finali.
		
	\end{itemize}

		
La validazione dev'essere una \emph{self fulfilling prophecy}, cioè bisogna essere certi che non fallirà; la verifica serve proprio a garantire questo. Infatti, il processo di verifica deve assicurarci che lavoriamo bene non a posteriori ma mentre lavoriamo. Se la verifica assicura i requisiti, la validazione li accerta. Il piano di qualifica nasce assieme ai requisiti.

		
	\subsection{Attività}

		
Il processo di ingegneria dei requisiti raggruppa quattro attività:
		
	\begin{enumerate}
		
			
	\item \textbf{studio di fattibilità} (stabilire se il sistema in questione è redditizio);
			
	\item acquisizione\footnote{Requirements elicitation.} e \textbf{analisi} dei requisiti;
			
	\item \textbf{specifica} dei requisiti (cioè formalizzare i requisiti);
			
	\item \textbf{validazione} dei requisiti.
		
	\end{enumerate}

		
Tale processo riguarda tutti gli stakeholders. In genere non è possibile soddisfare i requisiti di ognuno di essi, quindi bisogna quindi trovare un buon compromesso; questo presuppone quindi che gli stakeholders vengano identificati, "pesati" e interpellati.

		
	\subsection{Studio di fattibilità}

		
Lo studio di fattibilità è uno studio breve e chiaro che consiste nel valutare \textbf{rischi}, \textbf{costi} e \textbf{benefici} legati al sistema da sviluppare: tale sistema contribuisce agli obiettivi generali dell'organizzazione? può essere sviluppato rispettando determinati vincoli economici, con la tecnologia corrente? può essere integrato con altri sistemi in uso? una risposta negativa in una qualunque tra queste domande inficia la fattibilità del sistema. Lo studio di fattibilità dovrebbe descrivere in modo chiaro gli \textbf{obiettivi} del progetto e valutare approcci alternativi, per capire se il progetto proposto è la migliore alternativa.

		
	\subsection{Acquisizione e analisi dei requisiti}

		
Dopo aver compiuto uno studio di fattibilità, gli ingegneri del software devono lavorare assieme a clienti e utenti per individuare il dominio di applicazione e i requisiti del sistema. In generale, tutti gli stakeholders sono coinvolti in questa attività, che prende il nome di "acquisizione e analisi dei requisiti" e si svolge a grandi linee nel seguente modo.
		
	\begin{enumerate}
		
			
	\item Studio dei bisogni e delle fonti; si cerca di individuare un insieme (non strutturato) di requisiti. Per fare questo, si può:
				
	\begin{itemize}
		
					
	\item interrogare gli stakeholders --- con interviste chiuse (insieme predefinito di domande) o aperte;
					
	\item discutere con gli stakeholders alcuni scenari del sistema (uno scenario è la descrizione di un esempio di interazione col sistema);
					
	\item discutere con gli stakeholders i casi d'uso del sistema (tramite diagrammi che individuino le interazioni tra il sistema e i suoi utenti);
					
	\item studiare un prototipo del sistema;
					
	\item discutere in modo creativo, tramite brainstorming;
					
	\item osservare il sistema in modo etnografico, concentrandosi sul suo funzionamento abituale.
				
	\end{itemize}

			Interviste e scenari (oltre al capitolato d'appalto, chiaramente) sono fonte di requisiti espliciti; per ricavare, invece, i requisiti impliciti, gli ingegneri del software devono capire il dominio di applicazione del sistema (magari creando un glossario dei termini chiave del dominio).
			
			
	\item Classificazione e organizzazione dei requisiti; l'insieme dei requisiti viene strutturato, dividendo i requisiti in gruppi che rispecchino l'architettura del software (qui, progettazione e analisi procedono spesso insieme).
			
	\item Modellazione concettuale del sistema (ad esempio tramite un diagramma dei casi d'uso).
			
	\item Assegnazione dei requisiti a parti distinte del sistema.
			
	\item Negoziazione con il committente e con i sotto-fornitori: essendoci diversi stakeholders, è normale che alcuni requisiti siano in conflitto; bisogna dare una priorità ad ogni requisito e negoziare quelli incompatibili per trovare un compromesso.
		
	\end{enumerate}

		
I requisiti possono cambiare (a causa di condizioni esterne o anche solo perché l'analisi si è approfondita e ha introdotto nuovi requisiti); proprio per questo, è bene notare che la sequenza di passi riportata diventa spesso un ciclo che si ripete.

		
	\subsection{Specifica dei requisiti}
 % [...!]

		
I requisiti vanno specificati in un documento, usando un linguaggio formale o grafico. [?? ...] Vanno ordinati per priorità, classificati e identificati univocamente.

		
	\subsection{Validazione dei requisiti}

		
Validare i requisiti vuol dire controllare che essi definiscano effettivamente il sistema che il cliente richiede. A partire dal documento generato durante la specifica dei requisiti, bisogna assicurarsi che questi siano:
		
	\begin{itemize}
		
			
	\item non ambigui;
			
	\item necessari --- ogni requisito deve soddisfare qualche bisogno esplicito (dal capitolato di appalto);
			
	\item sufficienti --- ogni bisogno dev'essere soddisfatto da qualche requisito del documento;
			
	\item coerenti;
			
	\item realistici --- i requisiti devono essere implementabili con la tecnologia a disposizione;
			
	\item verificabili --- si dev'essere in grado di dimostrare che il sistema soddisfa i requisiti.
		
	\end{itemize}

	


		
	\section{Progettazione}


		
	\subsection{Definizione}

		
La risoluzione di un problema attraversa due fasi: la prima è \textbf{analitica}, la seconda \textbf{sintetica}. Nella fase analitica il problema viene decomposto, approfondito nel dettaglio per capire di quali parti è formato (approccio \emph{top-down}); in quella sintetica, invece, si ricompongono i pezzi trovati al passo precedente e si sintetizza una soluzione per il problema (approccio \emph{bottom-up}). Se la fase analitica ("qual è il problema?") corrisponde grosso modo all'attività di analisi dei requisiti, quella sintetica ("come risolvere il problema?") è proprio la progettazione. Formalmente, la progettazione è la definizione\footnote{Il termine "definizione" va inteso sia come processo sia come il risultato di tale processo.} dell'architettura, dei componenti, delle interfacce e delle altre caratteristiche di un sistema o componente.
		
L'architettura di un software è, tipicamente, un insieme di \textbf{moduli} che si raggruppano in \textbf{unità}, che a loro volta si raggruppano in \textbf{componenti}, che vanno a formare un \textbf{sistema}. Acronimo tattico per ricordarsi: SCUM.

		
	\subsection{Progettazione architetturale e progettazione di dettaglio}

		
Il processo di progettazione passa attraverso due attività, che si situano tra l'analisi dei requisiti e l'implementazione:
		
	\begin{itemize}
		
			
	\item \textbf{progettazione architetturale}, di alto livello, che descrive come il software viene organizzato in componenti;
			
	\item \textbf{progettazione di dettaglio}, che descrive il comportamento di tali componenti.
		
	\end{itemize}

		
Nel piano di qualifica, se l'analisi è verificata dal test di sistema, la progettazione architetturale è verificata dai test d'integrazione e quella di dettaglio dai test di unità. (Questo è il cosiddetto "modello a V".)

		
	\subsection{Architettura}

		
Obiettivo della progettazione è definire l'architettura del sistema. Per architettura s'intende la decomposizione di un sistema in componenti, l'organizzazione di tali componenti, le interfacce dei componenti e i loro paradigmi di composizione. In generale, una buona architettura deve rispettare i seguenti princìpi:
		
	\begin{itemize}
		
			
	\item sufficienza --- deve soddisfare tutti i requisiti;
			
	\item comprensibilità --- può essere capita dagli stakeholders;
			
	\item modularità --- le sue parti sono chiare e distinte, non si sovrappongono;
			
	\item robustezza --- è capace di gestire un'ampia classe di input diversi;
			
	\item flessibilità --- permette modifiche a costo contenuto;
			
	\item riusabilità --- alcune sue parti possono essere utilmente impiegate in altre applicazioni;
			
	\item efficienza;
			
	\item affidabilità --- è altamente probabile che svolga bene il suo compito;
			
	\item disponibilità --- necessita di poco tempo di manutenzione fuori linea;
			
	\item sicurezza rispetto ai malfunzionamenti;
			
	\item sicurezza rispetto a intrusioni;
			
	\item semplicità --- ogni parte contiene solo il necessario e niente di superfluo;
			
	\item incapsulamento --- nasconde i dettagli implementativi;
			
	\item coesione --- parti associate concorrono agli stessi obiettivi (l'approccio a oggetti aiuta molto a ottenere coesione);
			
	\item basso accoppiamento --- parti distinte dipendono il meno possibile le une dalle altre.
		
	\end{itemize}

		
Tutte queste qualità devono essere misurabili. In particolare, l'accoppiamento è misurabile interpretando le componenti di un sistema come i nodi di un grafo orientato dove gli archi sono dipendenze di un componente nei confronti di un altro; il numero di archi entranti (\emph{fan-in}) è indice di utilità, mentre il numero di archi uscenti (\emph{fan-out}) è indice di dipendenza. Riguardo alla riusabilità, infine, è bene notare che costituisce un guadagno soltanto nel lungo termine, mentre nel breve termine è un puro costo.

		
	\subsection{\emph{Design pattern} e stili architetturali}

		
Un \emph{design pattern} è una soluzione progettuale a un problema ricorrente. Per la progettazione esistono soluzioni progettuali di alto livello (gli stili architetturali) e di basso livello (i design pattern).

		
	\subsection{Progettazione architetturale}

		
Esistono vari stili architetturali e aderire a uno di essi garantisce coerenza; alcuni stili sono:
		
	\begin{itemize}
		
			
	\item strutture generali (livelli, oggetti, pipes e filtri, blackboard);
			
	\item sistemi distribuiti (\emph{client-server}, \emph{three-tiers}, \emph{peer-to-peer}, \emph{broker});
			
	\item sistemi interattivi (\emph{Model-View-Controller}, \emph{Presentation-Abstraction-Control});
			
	\item sistemi adattabili (microkernel, riflessione);
			
	\item altri (batch, interpreti...).
		
	\end{itemize}


		
	\subsection{Progettazione di dettaglio}

		
Uno stile architetturale è una soluzione progettuale di alto livello; per la progettazione di dettaglio, invece, si ricorre ai design pattern, che si dividono in tre famiglie:
		
	\begin{itemize}
		
			
	\item design pattern creazionali, che cercano di rendere un sistema indipendente dall'implementazione concreta delle sue componenti;
			
	\item design pattern strutturali, che affrontano problemi riguardanti la composizione di classi e oggetti;
			
	\item design pattern comportamentali, che si occupano del comportamento degli oggetti e delle collaborazioni tra essi.
		
	\end{itemize}

		
La progettazione di dettaglio deve definire delle unità il cui carico di lavoro sia realizzabile da un singolo programmatore, in parallelo con le altre unità. Quanto più piccolo è il compito tanto più piccolo è il rischio.
	


		
	\section{Documentazione}


		
	\subsection{Definizione}

		
Documentazione è tutto il materiale che documenta le attività di un progetto (e i loro prodotti). wikibooks.org afferma che, in ingegneria, l'obiettivo primario della documentazione di un prodotto è la \emph{replicabilità} di tale prodotto: \textquote{You are not an engineer until others can replicate what you have done [...] without your presence [...] without your words [...] without your physical personality on the planet.} I documenti di un progetto software e del prodotto che si sta sviluppando hanno diversi motivi di esistere:
		
	\begin{itemize}
		
			
	\item per i membri del progetto, sono un mezzo di comunicazione;
			
	\item per chi dovrà manutenere il prodotto, servono da repository di informazioni sul sistema;
			
	\item per l'amministrazione, forniscono informazioni che aiutano la pianificazione dello sviluppo;
			
	\item per gli utenti del prodotto, alcuni documenti sono utili per capire come interfacciarsi con il prodotto.
		
	\end{itemize}

		
I principali documenti di progetto sono:
		
	\begin{itemize}
		
			
	\item analisi dei requisiti;
			
	\item specifica software (descrizione ad alto livello del sistema);
			
	\item specifica tecnica (architettura logica);
			
	\item definizione di prodotto (architettura di dettaglio);
			
	\item manuale utente.
		
	\end{itemize}


		% AGGIUNGERE: /==> di processo documenti ====C /==> di sistema \==> di prodotto ====C \==> utente


		
	\subsection{Specifica software}

		
La specifica software dev'essere una descrizione ad alto livello del sistema tramite rappresentazione gerarchica.

		
	\subsection{Specifica tecnica}

		
La specifica tecnica (ST) segue l'analisi dei requisiti e descrive l'\textbf{architettura logica} del sistema, mostrando ciò che il sistema deve fare senza però fissarne i dettagli implementativi; difatti, la specifica tecnica descrive l'\emph{interfaccia} di ogni componente del sistema, attraverso più livelli gerarchici di decomposizione. In particolare, di ogni componente vengono specificati:
		
	\begin{itemize}
		
			
	\item funzione svolta;
			
	\item tipo dei dati in ingresso;
			
	\item tipo dei dati in uscita;
			
	\item risorse necessarie per il suo funzionamento.
		
	\end{itemize}


		
	\subsection{Definizione di prodotto}

		
Dall'architettura logica procede l'\textbf{architettura di dettaglio}, descritta dalla definizione di prodotto (DP). Questo documento decompone l'architettura in moduli a grana più fine, finché ogni modulo ha dimensione, coesione, complessità e accoppiamento tali per cui i moduli possano essere sviluppati in parallelo dai programmatori. La DP deve fornire tutti i dettagli necessari alla codifica e alla verifica di ciascun modulo\footnote{La natura del termine "modulo" è determinata dal linguaggio di programmazione che verrà usato.}. La DP consente di stimare costi e tempi di realizzazione.

		
	\subsection{Analisi dei requisiti}

		
Una delle preoccupazioni maggiori nel documentare l'analisi dei requisiti (AR) è il \textbf{tracciamento dei requisiti}. Tracciare un requisito significa motivarne l'esistenza, spiegando qual è l'origine di tale requisito (che magari non era esplicito e quindi è stato dedotto da requisiti più espliciti) e badando a garantire la necessità e la sufficienza di ogni requisito. Per fare tutto questo si può usare una matrice, un grafo o una qualsiasi struttura dati appropriata.

		
	\subsection{Manuale utente}

		
Il manuale utente (MU) ha la funzione di spiegare all'utente come utilizzare il prodotto. Chi lo redige deve stare attento allo stile: deve preferire frasi brevi, paragrafi focalizzati, uso di liste, stile semplice, terminologia precisa e uso della forma attiva dei verbi. Può essere di diversi tipi, a seconda del grado di esperienza dell'utente (manuale introduttivo, manuale completo...) e in diversi formati (cartaceo, PDF, ipertestuale...).

		
	\subsection{Tracciamenti}

		
In generale, i principali tracciamenti all'interno di un prodotto sono:
		
	\begin{itemize}
		
			
	\item tra requisiti utente (capitolato) e requisiti software (AR);
			
	\item tra requisiti software (AR) e descrizione dei componenti (ST);
			
	\item tra test di unità e moduli della progettazione di dettaglio (DP);
			
	\item tra test di integrazione e componenti architetturali (ST);
			
	\item tra test di sistema e requisiti software (AR);
			
	\item tra test di accettazione e requisiti utente (capitolato).
		
	\end{itemize}

	


		
	\section{Progetto didattico}


		
	\subsection{Motivazioni}

		
Un corso di Ingegneria del Software sarebbe incompleto senza un progetto didattico: è bene che lo studente si scontri in prima persona con un progetto di gruppo che rispecchi la logica di relazione "cliente-fornitore". Nello specifico, le principali entità del progetto didattico sono:
		
	\begin{itemize}
		
			
	\item Il cliente o \textbf{committente}, cioè chi ha commissionato il prodotto; generalmente è un'azienda o una startup, che pubblica un capitolato d'appalto in cui viene spiegato qual è il prodotto da realizzare.
			
	\item Il \textbf{fornitore}, cioè chi si impegna a fornire il prodotto richiesto dal committente; è un gruppo di sei o sette studenti che scelgono di rispondere ad un particolare capitolato d'appalto. Il gruppo è un'entità coesa provvista di nome, logo e e-mail per le comunicazioni ufficiali.
			
	\item Il docente, che nel nostro caso funge da \textbf{proponente}; il docente verifica e valuta\footnote{Nota bene: il docente valuta i documenti e il prodotto, non il codice; questo può essere guardato ma non viene valutato.} l'andamento dei vari progetti.
		
	\end{itemize}


		
	\subsection{Revisioni di avanzamento}

		
Il progetto si estende nell'arco di uno o due semestri. Il docente potrebbe scegliere tra due approcci: l'approccio "chiavi in mano" (i gruppi sono lasciati liberi e il docente torna il giorno della consegna del prodotto); l'approccio per revisioni (più interattivo). L'approccio adottato è il secondo, molto più didattico. Quindi la principale modalità d'interazione tra gruppi e docente sono le \textbf{revisioni di avanzamento}, che sono quattro:
		
	\begin{enumerate}
		
			
	\item Revisione dei Requisiti (RR);
			
	\item Revisione di Progettazione (RP);
			
	\item Revisione di Qualifica (RQ);
			
	\item Revisione di Accettazione (RA).
		
	\end{enumerate}

		
È importante notare che la logica sequenziale delle revisioni di avanzamento non implica che il modello di sviluppo scelto dai gruppi debba essere anch'esso sequenziale\footnote{Anzi, il modello di sviluppo più gettonato dai gruppi è quello incrementale, non quello sequenziale.}!
		
Ricordiamo che ISO/IEC 12207 prevede due diversi tipi di processi di revisione: l'audit process e il joint review process. Alla prima classe appartengono le due revisioni esterne con effetto bloccante: RR e RA; alla seconda classe appartengono le due revisioni interne con valenza informativa: RP e RQ.

		
	\subsection{Documentazione}

		
Tutto il progetto va documentato. In particolare, il fornitore deve documentare: le sue strategie di efficienza ed efficacia, nei documenti di strategia; le regole per attuare tali strategie, nelle Norme di Progetto. I documenti di strategia, che servono sia al fornitore sia al committente, sono:
		
	\begin{itemize}
		
			
	\item Il \textbf{Piano di Progetto}, che tratta delle strategie che il gruppo sceglie di adottare per essere efficiente; esso presenta l'organigramma dettagliato del fornitore, lo schema proposto per l'assegnazione e la rotazione dei ruoli di progetto, l'impegno complessivo previsto per ogni ruolo e per ogni individuo, e il conto economico preventivo di realizzazione del prodotto.
			
	\item Il \textbf{Piano di Qualifica}, che tratta dell'efficacia e garantisce che le attese verranno rispettate; esso illustra la strategia complessiva di verifica e validazione proposta dal fornitore.
		
	\end{itemize}

		
Invece, le \textbf{Norme di Progetto} interessano solo il fornitore (e il docente) ma non il committente; esse servono a fissare il way of working.
		
In generale, i principali documenti del progetto didattico sono:
		
	\begin{itemize}
		
			
	\item Documenti gestionali:
				
	\begin{itemize}
		
					
	\item Studio di Fattibilità;
					
	\item Norme di Progetto;
					
	\item Piano di Progetto;
					
	\item Piano di Qualifica.
				
	\end{itemize}

			
			
	\item Documenti tecnici:
				
	\begin{itemize}
		
					
	\item Analisi dei Requisiti;
					
	\item Specifica Tecnica;
					
	\item Definizione di Prodotto;
					
	\item Manuale Utente.
				
	\end{itemize}

			
		
	\end{itemize}

		
Possiamo suddividere i documenti anche tra interni (al gruppo) ed esterni. Documenti interni sono:
		
	\begin{itemize}
		
			
	\item Studio di Fattibilità;
			
	\item Norme di Progetto.
		
	\end{itemize}

		
Documenti esterni sono:
		
	\begin{itemize}
		
			
	\item Piano di Progetto;
			
	\item Piano di Qualifica;
			
	\item Analisi dei Requisiti;
			
	\item Specifica Tecnica;
			
	\item Definizione di Prodotto;
			
	\item Manuale Utente.
		
	\end{itemize}


		
	\subsection{Revisione dei Requisiti}

		
Questa revisione ha la funzione di concordare con il cliente una visione condivisa del prodotto atteso. Tale visione è documentata nel documento di Analisi dei Requisiti, che studia i requisiti e i casi d'uso del prodotto da realizzare. I documenti valutati sono:
		
	\begin{itemize}
		
			
	\item Studio di Fattibilità;
			
	\item Norme di Progetto;
			
	\item Piano di Progetto;
			
	\item Piano di Qualifica;
			
	\item \textbf{Analisi dei Requisiti}.
		
	\end{itemize}


		
	\subsection{Revisione di Progettazione}

		
Questa revisione può avvenire in una (sola) delle seguenti modalità:
		
	\begin{enumerate}
		
			
	\item Revisione di Progettazione \emph{minima};
			
	\item Revisione di Progettazione \emph{massima}.
		
	\end{enumerate}

		
La RP minima riguarda l'architettura del sistema \emph{ad alto livello}; essa ha la funzione di accertare la realizzabilità del prodotto. I documenti valutati sono:
		
	\begin{itemize}
		
			
	\item Norme di Progetto;
			
	\item Piano di Progetto;
			
	\item Piano di Qualifica;
			
	\item \textbf{Specifica Tecnica}.
		
	\end{itemize}

		
La RP massima riguarda l'architettura \emph{di dettaglio} del sistema; essa ha la funzione di accordarsi sulle caratteristiche del prodotto da realizzare. I documenti valutati sono:
		
	\begin{itemize}
		
			
	\item Norme di Progetto;
			
	\item Piano di Progetto;
			
	\item Piano di Qualifica;
			
	\item \textbf{Definizione di Prodotto}.
		
	\end{itemize}


		
	\subsection{Revisione di Qualifica}

		
Questa revisione ha la funzione di approvare l'esito finale delle verifiche e attivare quindi la validazione. I documenti valutati sono:
		
	\begin{itemize}
		
			
	\item Norme di Progetto;
			
	\item Piano di Progetto;
			
	\item Piano di Qualifica;
			
	\item Definizione di Prodotto;
			
	\item versione preliminare del Manuale Utente.
		
	\end{itemize}


		
	\subsection{Revisione di Accettazione}

		
Questa revisione ha la funzione di collaudare il sistema e di accertare il soddisfacimento di tutti i requisiti utente stabiliti nell'Analisi dei Requisiti. I documenti valutati sono le versioni definitive di:
		
	\begin{itemize}
		
			
	\item Piano di Progetto;
			
	\item Piano di Qualifica;
			
	\item Manuale Utente.
		
	\end{itemize}


		
	\subsection{Ore di lavoro}

		
Le ore di lavoro si contano solo \emph{dopo} la valutazione della RR; fino a quel momento, il tempo speso è tempo d'investimento non rendicontato (eventualmente registrato, ma non rendicontato). Le ore totali impiegate a progetto da ciascuna persona sono circa 25-30 ore di lavoro; a questo proposito, è bene notare come l'efficienza è proporzionale al rapporto tra ore di lavoro e ore effettive. L'impegno totale di ore rendicontabili presentate a consuntivo da ogni componente di un gruppo dovrà situarsi fra un minimo di 85 e un massimo di 105 ore produttive. Le ore rendicontabili non includono le attività di auto-formazione.
	


		
	\section{Qualità del software}


		
	\subsection{Definizione di qualità}

		
Secondo ISO, la qualità è l'insieme delle caratteristiche di un'entità che ne determinano la capacità di soddisfare esigenze espresse e implicite. Valutare la qualità del software serve sia a chi lo ha realizzato (per migliorarlo), sia a chi lo usa (per avere garanzie), sia a chi valuta (per imparare). Tuttavia, quello di qualità è un concetto ambivalente: può riguardare la conformità ai requisiti (visione intrinseca della qualità), la soddisfazione del cliente (visione relativa) o la misura del livello di qualità (visione quantitativa); ad ogni modo, tutte queste sono aree in cui interviene il "sistema qualità".

		
	\subsection{Il sistema qualità}

		
ISO definisce il "sistema qualità" come la struttura organizzativa, le responsabilità, le procedure, i procedimenti e le risorse messe in atto per il perseguimento della qualità. Questo sistema gestisce la qualità in tre ambiti:
		
	\begin{itemize}
		
			
	\item La \textbf{pianificazione}, cioè le attività del sistema qualità mirate a fissare gli obiettivi di qualità, con i processi e le risorse necessari per conseguire tali obiettivi; è una premessa al controllo della qualità.
			
	\item Il \textbf{controllo}, cioè le attività del sistema qualità pianificate e attuate affinché il prodotto soddisfi i requisiti attesi.
			
	\item Il \textbf{miglioramento continuo}, secondo lo schema PDCA.
		
	\end{itemize}

		
Il sistema qualità è fissato nelle Norme di Progetto (il Piano di Qualifica fissa invece gli \emph{obiettivi} di qualità: i piani fissano solo obiettivi e strategie per raggiungerli).% ... boh?!


		
	\subsection{Modelli della qualità}

		
Per uniformare la percezione e la valutazione della qualità, è bene che committenti e fornitori si accordino su un \textbf{modello} da seguire per la qualità. Esistono vari modelli della qualità; ognuno di essi definisce le caratteristiche rilevanti che deve avere un prodotto "di qualità" e organizza tali caratteristiche in una struttura logica.
		
Ad esempio, ISO/IEC 9126 definisce 7 caratteristiche principali (suddivise poi in 31 sotto-caratteristiche):
		
	\begin{itemize}
		
			
	\item funzionalità;
			
	\item affidabilità;
			
	\item efficienza;
			
	\item usabilità;
			
	\item manutenibilità;
			
	\item portabilità;
			
	\item qualità in uso.
		
	\end{itemize}

		
Oltre a descriverle, il modello specifica anche come \emph{misurarle}, cioè assegna ad ogni caratteristica una metrica (che è un modo per dare un significato a dei valori). Un modello è quindi uno strumento di definizione e di valutazione:
		
	\begin{itemize}
		
			
	\item \textbf{definizione} perché cataloga in modo sistematico delle caratteristiche rilevanti;
			
	\item \textbf{valutazione} perché definisce delle metriche per la misurazione di tali caratteristiche.
		
	\end{itemize}

		
Sempre in ISO/IEC 9126, vengono proposte tre visioni della qualità:
		
	\begin{itemize}
		
			
	\item Visione esterna, relativa all'esecuzione del prodotto; è ciò che si osserva, quindi solo la punta dell'iceberg.
			
	\item Visione interna, relativa al prodotto \emph{non} in esecuzione; è ciò che deriva dalle scelte di progettazione, codifica e verifica, quindi si può vedere solo attraverso una revisione critica del prodotto.
			
	\item Visione in uso, relativa alla percezione dell'utente finale.
		
	\end{itemize}

		
Mentre le visioni interna ed esterna si riferiscono al prodotto software, la visione in uso si riferisce agli \emph{effetti} di tale prodotto.

		
	\subsection{Qualità nel ciclo di vita}

		
Possiamo individuare una catena di dipendenze tra le varie visioni della qualità: la \textbf{qualità di un processo} influenza gli attributi della \textbf{qualità interna}, che influenza gli attributi della \textbf{qualità esterna}, che influenza gli attributi della \textbf{qualità in uso}.
		
È bene che i seguenti aspetti siano il meno distante possibile tra loro:
		
	\begin{enumerate}
		
			
	\item qualità obiettivo;
			
	\item qualità richiesta;
			
	\item qualità progettata;
			
	\item qualità stimata;
			
	\item qualità consegnata.
		
	\end{enumerate}

		
Il committente ha responsabilità sulle prime due; il fornitore su tutte quante tranne la prima.

		
	\subsection{Metriche e misurazioni}

		
Una \textbf{metrica} è un modo per dare un significato a dei valori, quindi è l'interpretazione di un sistema di unità di misura. Una \textbf{misurazione quantitativa} è l'uso di una metrica per assegnare un valore su una scala predefinita.
		
Le metriche software permettono di quantificare sia un prodotto (e quindi predire i suoi attributi) sia un processo (al fine di monitorarlo e migliorarlo).
		
L'uso di una metrica assume che:
		
	\begin{itemize}
		
			
	\item Si può misurare un certo attributo (o proprietà) del software.
			
	\item Esiste una relazione tra ciò che possiamo misurare e ciò che vogliamo sapere. Ad esempio, generalmente è possibile misurare solo attributi \emph{interni} del software, mentre ciò che più spesso ci interessa sono i suoi attributi \emph{esterni}: per capire il grado di manutenibilità di un software (attributo esterno), dobbiamo conoscere il numero di righe di codice, il numero di parametri per procedura, l'ampiezza del manuale utente... (attributi interni).
			
	\item La suddetta relazione è stata formalizzata e validata.
		
	\end{itemize}

		
La selezione delle metriche (e la scelta dei criteri di accettazione) parte dall'analisi dei requisiti di qualità e dei vincoli di costo. Dopodiché:
		
	\begin{enumerate}
		
			
	\item una volta selezionate le metriche, si può procedere alla misurazione;
			
	\item poi si passa alla valutazione (che è una verifica quantificata);
			
	\item e infine viene l'accettazione --- basandosi, appunto, sui criteri di accettazione scelti.
		
	\end{enumerate}

	


		
	\section{Qualità di processo}


		
	\subsection{Risalire dal prodotto al processo}

		
Da tubi sporchi non esce acqua pulita: per ottenere \emph{prodotti} di qualità, è necessario avere \emph{processi} di qualità. In altre parole, la \textbf{qualità di processo} sta a monte rispetto alla qualità di prodotto.
		
Un processo è una macchina che prende in input dei bisogni e dà in output dei prodotti, consumando risorse nel farlo. Come tutte le macchine, un processo va controllato; questo permette di assicurare che i prodotti che produce siano quelli desiderati. Per controllare un processo, come per controllare una \emph{self-driving car} in movimento, sono necessari dei sensori e degli attuatori: gli uni per conoscere lo stato del processo (la posizione della macchina), gli altri per modificare l'implementazione del processo (la direzione in cui va la macchina). In questo paragone il controllore del processo è la \textbf{\emph{quality assurance}}, i sensori sono delle \textbf{misurazioni} che vengono effettuate sul processo e gli attuatori sono \textbf{regole e decisioni} atte a migliorare il processo.
		
Tutto questo, per essere efficiente, va fatto con misurazioni preventive (e non a posteriori) il cui obiettivo è il continuo miglioramento del processo: la qualità di processo segue il ciclo PDCA.

		
	\subsection{ISO 9000}

		
Il concetto di qualità di processo fu introdotto dai \emph{big spender}, per avere delle classifiche oggettive di fornitori ed essere, quindi, più sereni. Nel 1987 nacque dunque ISO 9000, una famiglia di standard che riguardano i sistemi di gestione della qualità (QMS, Quality Management System). Questa famiglia di standard non si occupa solo di software ma astrae dal dominio di applicazione.
		
ISO 9000, come documento, introduce i fondamenti e un glossario; invece, ISO 9001 si occupa di calare la visione di ISO 9000 nei \textbf{sistemi produttivi}, introducendo dei requisiti ben specifici. Esistono enti che si occupano di certificare il rispetto di tali requisiti (ISO 9001 è quindi anche una \emph{certificazione}). Infine, ISO 9004 è una guida al miglioramento dei risultati.
		
Questa famiglia di standard si basa su 7 princìpi di gestione della qualità (QMP):
		
	\begin{itemize}
		
			
	\item QMP 1 --- customer focus
			
	\item QMP 2 --- leadership
			
	\item QMP 3 --- engagement of people
			
	\item QMP 4 --- process approach
			
	\item QMP 5 --- improvement
			
	\item QMP 6 --- evidence-based decision making
			
	\item QMP 7 --- relationship management
		
	\end{itemize}


		
	\subsection{Sistema di gestione della qualità}

		
La gestione della qualità, come funzione aziendale, dovrebbe essere al di sopra dei vari settori e dovrebbe riferire direttamente alla direzione; questa funzione deve infatti garantire la qualità in modo \emph{trasversale} ai vari settori.
		
Il sistema di gestione della qualità è documentato tramite:
		
	\begin{itemize}
		
			
	\item Una \textbf{politica per la qualità}, cioè le motivazioni che stanno alla base delle scelte sulla qualità.
			
	\item Il \textbf{manuale della qualità}, che definisce il QMS di un'oraganizzazione. Adotta una visione \emph{operativa} (orizzontale, ad alto livello).
			
	\item Il \textbf{piano della qualità}, una concretizzazione del manuale della qualità che adotta una visione \emph{strategica} (verticale). Esso definisce gli elementi del QMS e le risorse che devono essere applicate in uno specifico caso (prodotto, processo o progetto). Può avere valenza contrattuale. Nel progetto didattico, il piano della qualità è integrato nel piano di qualifica.
		
	\end{itemize}


		
	\subsection{Strumenti di valutazione}

		
Alcuni strumenti per la valutazione della qualità di processo:
		
	\begin{itemize}
		
			
	\item SPY (Software Process assessment and Improvement)
			
	\item CMMI (Capability Maturity Model with Integration)
			
	\item SPICE (Software Process Improvement Capability dEtermination)
		
	\end{itemize}

		
\textbf{SPY} si incentra sulla valutazione oggettiva dei processi di un'organizzazione. Esso fornisce un giudizio di maturità e individua azioni migliorative.
		
\textbf{CMMI} si basa su quattro termini:
		
	\begin{enumerate}
		
			
	\item Capability --- misura di quanto è adeguato un singolo processo, rispetto agli scopi per cui è stato definito. Un processo ad alto livello di capability è seguito da tutti in modo disciplinato, sistematico e quantificabile.
			
	\item Maturity --- misura di quanto è governato l'intero sistema di processi dell'organizzazione. L'intelligenza dei processi di un'organizzazione si chiama \emph{governance}.
			
	\item Model --- insieme di requisiti via via più stringenti per valutare il percorso di miglioramento dei processi dell'organizzazione.
			
	\item Integration --- architettura di integrazione delle diverse discipline (sistema, hardware, software) e tipologie di attività delle organizzazioni.
		
	\end{enumerate}

		
È bene notare che mentre la capability è caratteristica di un singolo processo, la maturity è caratteristica di un insieme di processi.
		
La governance di un'organizzazione ha interesse ad alzare il livello di maturity dell'organizzazione, dato che questo influenza direttamente la capability. CMMI definisce cinque livelli di maturità:
		
	\begin{enumerate}
		
			
	\item \textbf{initial} --- i processi sono imprevedibili, poco controllati e poco reattivi;
			
	\item \textbf{managed} --- l'organizzazione applica la "D" di PDCA: i processi sono caratterizzati per i progetti e sono spesso reattivi;
			
	\item \textbf{defined} --- l'organizzazione applica la "P" di PDCA: i processi sono caratterizzati per l'organizzazione e sono proattivi;
			
	\item \textbf{quantitatively managed} --- l'organizzazione applica "PC" di PDCA: i processi sono misurati e controllati;
			
	\item \textbf{optimized} --- l'organizzazione applica PDCA in toto: l'organizzazione si concentra sul miglioramento dei processi.
		
	\end{enumerate}

		
Nota bene: la "P" di PDCA è pianificazione di \emph{miglioramento}, non pianificazione di progetto.
		
Limitazioni di CMMI sono: la sua natura discreta (non continua: quindi potenzialmente frustrante per le organizzazioni); un'eccessiva concentrazione sulle pratiche (cosa si fa e come); un'insufficiente attenzione agli obiettivi (perché lo si fa).
		
\textbf{SPICE} è nato nel 1992 per armonizzare SPY con ISO/IEC 12207 e ISO 9001; nel 1998 è confluito in ISO/IEC 15504 (creato da ISO a partire da CMMI. Qui scompare il concetto di maturity e, al posto dei cinque gradini di maturità, si usa una scala più fine. Le aziende vengono misurate secondo il fatturato e il personale. La sua metodologia di valutazione è la seguente:
		
	\begin{itemize}
		
			
	\item identificazione dei portatori d'interesse (\emph{stakeholders}: utenti, sviluppatori, valutatori...);
			
	\item scelta tra valutazione e miglioramento;% mboh...

			
	\item definizione della portata (quali processi vanno inclusi nella valutazione?).
		
	\end{itemize}

	


		
	\section{Verifica e validazione: introduzione}


		
	\subsection{Definizione}

		
Verifica e validazione sono due processi strettamente correlati. A questa coppia di processi si dà spesso il nome di "\textbf{qualifica}" o "V\&{}V". Il loro obiettivo è assicurare la qualità del prodotto durante il suo ciclo di vita.
		
Questi due processi rispondono a due domande separate:
		
	\begin{itemize}
		
			
	\item Verifica: \textquote{Did I build the system right?}
			
	\item Validazione: \textquote{Did I build the right system?}
		
	\end{itemize}

		
La \textbf{verifica} attiene alla coerenza, completezza e correttezza del prodotto. È un processo che si applica ad ogni "segmento" temporale di un progetto (ad ogni prodotto intermedio) per accertare che le attività svolte in tale segmento non abbiano introdotto errori nel prodotto.
		
La \textbf{validazione}, invece, non si applica ad un particolare segmento temporale ma è una conferma finale, una \emph{self-fulfilling prophecy} che accerta la conformità di un prodotto alle attese; essa fornisce una prova oggettiva di come le specifiche del prodotto siano conformi al suo scopo e alle esigenze degli utenti. La validazione, a differenza della verifica, coinvolge sempre il committente.

		
	\subsection{Forme di verifica}

		
La verifica è un processo analitico. Si può fare in due forme:
		
	\begin{itemize}
		
			
	\item analisi statica (senza eseguire il software);
			
	\item analisi dinamica (eseguendo il software o una sua parte).
		
	\end{itemize}

		
L'analisi statica viene fatta prima di quella dinamica: quest'ultima necessita di (una parte di) software eseguibile, mentre l'analisi statica si può applicare già a \emph{frammenti} di prodotto.

		
	\subsection{Test}

		
L'analisi dinamica viene effettuata tramite prove (\emph{\textbf{test}}). Un test, per essere utile, dev'essere facilmente ripetibile; per questo, bisogna sempre:
		
	\begin{itemize}
		
			
	\item tener conto dell'ambiente (non solo dell'input);
			
	\item specificare le pre-condizioni e i comportamenti attesi;
			
	\item descrivere le procedure per eseguire il test e per analizzarne i risultati.
		
	\end{itemize}

		
Per fare ciò, servono tre strumenti:
		
	\begin{itemize}
		
			
	\item Un \textbf{logger}, che scriva l'esito della prova in un file.
			
	\item Un \textbf{driver}, cioè un "pilota" che guidi l'esecuzione del test. Ogni test di unità dev'essere chiamato da qualcuno: costui è il driver.
			
	\item Uno \textbf{stub}, cioè un "calco" che sostituisca del codice non ancora scritto: una componente passiva fittizia che simula una parte del sistema\footnote{La parte di sistema simulata dallo stub non è oggetto del test in esecuzione.}.
		
	\end{itemize}

		
Lo stub è quindi il duale del driver: mentre il primo simula le dipendenze della procedura testata (quelle che ne accrescono il \emph{fan-out}, per capirci), il secondo simula un chiamante di tale procedura (che contribuisce al \emph{fan-in}).

		
	\subsection{Tipi di test}

		
Distinguiamo quattro tipi di test, a seconda del livello a cui vengono eseguiti nell'architettura:
		
	\begin{itemize}
		
			
	\item collaudo o test di accettazione (stabilito durante l'analisi del capitolato d'appalto);
			
	\item test di sistema (stabiliti durante l'analisi dei requisiti);
			
	\item test di integrazione (stabiliti durante la progettazione logica);
			
	\item test di unità (stabiliti durante la progettazione di dettaglio).
		
	\end{itemize}

		
Nell'architettura di un software, l'unità è la più piccola quantità di software che conviene verificare da sola. Un \textbf{test di unità} è un'attività di analisi dinamica che verifica la correttezza del codice. Può essere responsabilità del programmatore che ha implementato l'unità\footnote{Per le unità più semplici.}, di un verificatore indipendente oppure (meglio!) di un automa. Questi test vengono svolti con un alto grado di parallelismo (rispecchiando lo stesso parallelismo che caratterizza il lavoro dei programmatori).
		
I \textbf{test di integrazione} servono per verificare il sistema in modo \emph{incrementale}. Questi test stanno a livello di componente e integrano il funzionamento di più unità.
		
Il \textbf{test di sistema} serve ad accertare la copertura dei requisiti. È un'attività interna all'organizzazione, mentre il \textbf{collaudo} è la corrispondente attività esterna (supervisionata dal committente). Al collaudo segue il rilascio del prodotto e la fine della commessa (con eventuale manutenzione).
		
Infine, esistono anche i \textbf{test di regressione}: a seguito di un test andato male e di una relativa correzione, i test di regressione sono l'insieme di test necessari ad accertare he la correzione non causi errori nelle parti del sistema che dipendono da essa. La regressione può essere complicata e dev'essere studiata \emph{ad hoc}.

		
	\subsection{Forme di analisi statica}

		
L'analisi statica si applica ad ogni prodotto intermedio (non solo software) per tutti i processi attivi nel progetto. Distinguiamo due tecniche principali per fare analisi statica:
		
	\begin{itemize}
		
			
	\item Metodi di lettura (\emph{desk check}), svolti da un umano che controlla coerenza, completezza e correttezza; impiegati solo per prodotti semplici.
			
	\item Metodi formali, svolti da macchine.
		
	\end{itemize}

		
Tra i metodi di lettura, due importanti sono \emph{inspection} (cerco cose specifiche) e \emph{walkthrough} (attraversamento a pettine: non so cosa cerco ma cerco ovunque), che si completano a vicenda.
		
\textbf{\emph{Inspection}} consiste nell'eseguire una lettura mirata, alla ricerca di errori noti. Si basa sull'individuazione di errori presupposti e fa \emph{profiling} del prodotto in esame. Si suddivide nelle seguenti attività: pianificazione; definizione di una \emph{lista di controllo}\footnote{La lista di controllo (o checklist) evolve nel tempo, in quanto viene continuamente migliorata.}; lettura; correzione dei difetti. È una tecnica molto più rapida del \emph{walkthrough}. In termini statistici, \emph{inspection} può generare falsi negativi.
		
\textbf{\emph{Walkthrough}}, invece, consiste nell'eseguire una lettura critica del prodotto in esame. È una lettura "a largo spettro", senza l'assunzione di presupposti. Si articola nelle seguenti attività: pianificazione; lettura; discussione; correzione dei difetti. Rispetto all'\emph{inspection}, richiede più attenzione. In termini statistici, \emph{walkthrough} può generare falsi positivi.

		
	\subsection{\emph{Quality assurance}}

		
Analisi statica e analisi dinamica sono parte dell'attività di \emph{quality assurance} (cioè garanzia di qualità). Questa attività è un controllo che non viene fatto dopo ma \emph{prima} di fare, per assicurare la qualità tempestivamente; viene svolta sui processi con i quali si sviluppa il prodotto (non sul prodotto stesso) ma si basa su un modello di qualità di prodotto (ad esempio ISO/IEC 9126).
	


		
	\section{Verifica e validazione: analisi statica}


		
	\subsection{Premessa}

		
Un software di buona qualità deve possedere le capacità funzionali specificate nei requisiti e le caratteristiche non funzionali\footnote{Oggigiorno, i requisiti non funzionali pesano anche più di quelli funzionali: non bisogna più soltanto "fare dei conti" ma anche farli bene, velocemente, in modo responsivo...} necessarie al buon funzionamento del sistema. Bisogna quindi verificare che il software posseggna determinate caratteristiche di costruzione (progettazione, codifica, integrazione), d'uso e di funzionamento.
		
Tanto più un linguaggio di programmazione è espressivo, tanto tanto meno è verificabile. Nel fissare il liguaggio di programmazione (e nel sceglierne i costrutti), occorre quindi trovare il giusto compromesso tra \textbf{funzionalità} (potere espressivo) e \textbf{integrità} (costo di verifica). Inoltre, è bene adottare uno standard di codifica che tenga conto delle esigenze di verifica (per esempio, vietando alcuni costrutti): così facendo, si rende possibile una verifica che non sia retrospettiva ma che accompagna la codifica.
		
Infatti, il costo di rilevazione e correzione di un errore è tanto maggiore quanto più avanzato è lo stadio di sviluppo. Ecco perché ci interessa accompagnare la produzione con la verifica, invece di posticipare la verifica il più tardi possibile.

		
	\subsection{Tracciamento}

		
Parte fondamentale dell'analisi statica è il \textbf{tracciamento}. Il tracciamento è una verifica atta a dimostrare due caratteristiche di una soluzione:
		
	\begin{itemize}
		
			
	\item \textbf{Completezza} della soluzione: tutti i requisiti sono soddisfatti; matematicamente, vuol dire che la soluzione è \emph{condizione sufficiente} per il problema.
			
	\item \textbf{Economicità} della soluzione: nessuna funzionalità superflua, nessun componente ingiustificato; matematicamente, vuol dire che la soluzione è \emph{condizione necessaria} per il problema.
		
	\end{itemize}

		
Il tracciamento ha luogo su ogni passaggio dello sviluppo (ramo discendente del modello a "V") e su ogni passaggio della verifica (ramo ascendente).

		
	\subsection{Tipi di analisi statica}

		
L'analisi statica si effettua con diversi metodi:
		
	\begin{itemize}
		
			
	\item analisi di flusso di controllo;
			
	\item analisi di flusso dei dati;
			
	\item analisi di flusso dell'informazione;
			
	\item esecuzione simbolica;
			
	\item verifica formale del codice;
			
	\item verifica di limite;
			
	\item analisi d'uso dello stack;
			
	\item analisi temporale;
			
	\item analisi d'interferenza;
			
	\item analisi del codice oggetto.
		
	\end{itemize}

		
L'analisi statica costruisce modelli astratti del software in esame; questi modelli considerano ogni programma come un grafo orientato e ne studiano i cammini possibili.
	


		
	\section{Verifica e validazione: analisi dinamica}


		
	\subsection{Definizione e problemi}

		
L'analisi dinamica non è altro che l'esecuzione di \textbf{\emph{test}}, cioè prove su del codice in esecuzione. Purtroppo nello sviluppo di un software il codice nasce molto tardi; per questo, il \emph{testing} dev'essere rapido (efficiente) ed efficace\footnote{È interessante notare che il testing viene fatto sempre: se non lo fa il fornitore, lo farà l'utente. Ovviemante, dare all'utente un software non testato è una cosa che non va fatta.}. Un altro problema dei test è la loro \textbf{non esaustività}: è possibile eseguirli solo su un insieme finito di casi, che non sono quasi mai tutti i casi possibili.
		
La pianificazione del \emph{testing} deve quindi avvenire il prima possibile. Il primo momento utile è la progettazione del sistema.
		
Il debugging \emph{non} è verifica: esso nasce da un errore che si è manifestato inaspettatamente, mentre la verifica viene pianificata a monte dello sviluppo.

		
	\subsection{Terminologia}

		
Compito del test è trovare errori nel codice. Distinguiamo tre livelli di errore:
		
	\begin{itemize}
		
			
	\item \textbf{Malfunzionamento} (\emph{failure}): l'esecuzione è difforme dalle attese. I malfunzionamenti riguardano il comportamento del software.
			
	\item \textbf{Errore} (\emph{error}): stato del sistema che, se attivato, produce un malfunzionamento; se l'errore non viene attivato, rimane nascosto ma esiste. Gli errori sono quindi stati del sistema.
			
	\item \textbf{Guasto} o difetto (\emph{fault}): causa dell'errore; può essere un guasto del computer o del software. I guasti possono essere malfunzionamenti di un sotto-sistema: i sistemi software sono sistemi gerarchici (annidati).
		
	\end{itemize}

		
Quindi: un guasto cause un errore, il quale può produrre un malfunzionamento. (Nota: il glossario IEEE non concorda pienamente con le definizioni sopra.)
		
Organizziamo il \emph{testing} nelle seguenti classi:
		
	\begin{itemize}
		
			
	\item \textbf{caso di prova} (\emph{test case}) --- una tripla \textless{}ingresso, uscita, ambiente\textgreater{};
			
	\item \textbf{batteria di prove} (\emph{test suite}) --- un insieme di casi di prova;
			
	\item \textbf{prova} --- una procedura di prova e una batteria di prove.
		
	\end{itemize}


		
	\subsection{Compromesso}

		
Esiste un compromesso, come tra efficienza ed efficacia, tra il numero di test sufficienti a verificare il prodotto e lo sforzo allocato a progetto. Sul \emph{testing} vale infatti la "legge del \textbf{rendimento decrescente}\footnote{In inglese diminishing returns.}": man mano che aumento lo sforzo, il rendimento cresce inizialmente ma poi diminuisce sempre più. Questo avviene, ad esempio, quando un produttore aumenta la produzione e, a un certo punto, oltrepassa la domanda: i profitti iniziano ad essere negativi. Così, arriva un tempo in cui fare altri test non aggiunge null, cioè non trova errori (e la funzione primaria dei test è trovare errori).

		
	\subsection{Criteri guida per i test}

		
Oggetto di una prova può essere:
		
	\begin{itemize}
		
			
	\item il sistema nel suo complesso (per i test di sistema);
			
	\item parti del sistema in relazione funzionale, d'uso, di comportamento o di struttura (per i test di integrazione);
			
	\item singole unità (per i test di unità).
		
	\end{itemize}

		
L'obiettivo di ogni prova dev'essere specificato in modo chiaro per ogni caso di prova (\emph{test case}): un test è buono se è ripetibile. Per essere ripetibile, ogni test deve stare anche allo stato, all'ambiente. Il Piano di Qualifica specifica quali e quante sono le prove da effettuare. I test non sostituiscono la progettazione; piuttosto, sono speculari ad essa.
		
Un test deve cercare di far fallire il software: dev'essere "cinico"! I test che falliscono devono essere eseguiti sempre, dal momento in cui sono falliti e il software è stato corretto: \textquote{Any failed execution must yield a test case, to be permanently included in the project's test suite} (Bertrand Meyer).
		
All'origine, un test va specificato in fase di progettazione; dopo essere stato implementato ed eseguito, esso va tenuto in un archivio, come documentazione dell'attività di \emph{testing}.

		
	\subsection{Test di unità}

		
I test di unità sono naturalmente più numerosi dei test di integrazione e di unità: circa due terzi dei difetti rilevati tramite analisi dinamica sono dovuti ai test di unità.
		
Un concetto fondamentale nei test di unità è quello di \textbf{copertura} (\emph{coverage}). Con questo termine si intende il la percentuale di codice che un caso di prova è in grado di eseguire, cioè quanto codice sorgente è stato effettivamente attraversato durante il caso di prova; ad esempio, una copertura del 100\% indica che l'esecuzione di un test ha coperto tutti i casi possibili del codice in esame.
		
Alcuni criteri notevoli di copertura sono i seguenti:
		
	\begin{itemize}
		
			
	\item \emph{function coverage} --- quante funzioni (sottoprocedure) sono state eseguite?
			
	\item \emph{statement coverage} --- quante istruzioni (righe di codice, all'incirca) sono state eseguite?
			
	\item \emph{branch coverage} --- quanti rami\footnote{Qui stiamo studiando un programma come un albero.} del programma sono stati eseguiti?
			
	\item \emph{condition coverage} --- quante espressioni logiche hanno assunto entrambi i valori possibili?
		
	\end{itemize}

		
Di queste, le più importanti sono lo \emph{statement coverage} e, ancor più, il \emph{branch coverage}. È sempre bene che i test di unità coprano il codice al 100\% rispetto a questi ultimi due criteri; tuttavia, va ricordato che la copertura totale del codice non assicura l'assenza di difetti! Un criterio ancora più forte del \emph{branch coverage} è il MC/DC (\emph{Modified Condition/Decision Coverage}).
		
Distinguiamo due categorie di test di unità:
		
	\begin{itemize}
		
			
	\item Un \textbf{test funzionale} è un test a scatola chiusa (\emph{black box}). Fa riferimento alla specifica di un'unità e osserva il suo comportamento dal di fuori; dati in ingresso che producono un medesimo comportamento funzionale costituiscono una classe di equivalenza e sono un caso di prova.
			
	\item Un \textbf{test strutturale} è un test a scatola aperta (\emph{white box}): verifica la logica interna del codice dell'unità. Persegue la massima copertura\footnote{La copertura interessa soltanto i test strutturali, non quelli funzionali.} del codice sorgente; dati in ingresso che attivano un medesimo percorso costituiscono un caso di prova.
		
	\end{itemize}

		
Dobbiamo eseguire i test funzionali prima di quelli strutturali, se non vogliamo rischiare di analizzare una struttura che non svolge il compito giusto. I test funzionali vanno sempre integrati con test strutturali.

		
	\subsection{Test di integrazione}

		
I test d'integrazione fanno parte di un processo più ampio che è quello dell'integrazione delle parti del sistema. Le parti vanno integrate secondo una strategia. Ad esempio è sempre bene assemblare le parti in modi incrementale (quindi reversibile), seguendo le dipendenze nell'architettura: aggiungendo una parte nuova ad un insieme ben verificato, i difetti rilevati in un test d'integrazione saranno probabilmente dovuti alla parte nuova, facilitando così la ricerca di quale parte sia da correggere.
		
Basandoci sul fatto che i sistemi software sono (al giorno d'oggi) sistemi gerarchici, possiamo individuare due principali \textbf{strategie d'integrazione}:
		
	\begin{itemize}
		
			
	\item Dal basso (bottom-up): si sviluppano e si integrano prima le parti con minore dipendenza funzionale (\emph{fan-out}) e maggiore utilità (\emph{fan-in}). Così facendo, si "risale" l'albero delle dipendenze. Si economizzano molti stub ma le funzionalità di alto livello compaiono più tardi.
			
	\item Dall'alto (top-down): si sviluppano prima le parti più esterne (di alto livello, con molte dipendenze) e poi si scende nell'albero delle dipendenze. Qui le funzionalità di alto livello vengono verificate sin da subito e si può mostrare al committente una bozza del sistema.
		
	\end{itemize}

		
I test d'integrazione si applicano alle componenti specificate in progettazione architetturale; perciò, questi test rilevano difetti di progettazione. L'integrazione delle componenti costituisce il sistema completo.
		
Quanti test d'integrazione è bene fare? tanti quante sono le interfacce nell'architettura del sistema: i test d'integrazione devono accertare che i dati scambiati attraverso ciascuna interfaccia siano conformi alla propria specifica.

		
	\subsection{Test di sistema}

		
I test di sistema verificano il comportamento del sistema rispetto ai suoi \textbf{requisiti}. Essi sono inerentemente funzionali: non hanno bisogno di conoscere la logica interna del sistema.
	


		
	\section{Metodi e obiettivi di quantificazione}


		
	\subsection{Misurare}

		
Misurare è un'attività fondamentale che compiamo quotidianamente: \textquote{You can't control what you can't measure} afferma Tom DeMarco, informatico e ingegnere del software. Misurare serve a conoscere, a valutare e a decidere; è un'attività che è alla base della cibernetica\footnote{La cibernetica si occupa del controllo di attuatori, grazie a misurazioni raccolte da sensori.}.
		
Purtroppo le misure rischiano di essere distorte, a causa di semplificazioni e imprecisioni. Per accertare la bontà di una misura essa dev'essere oggettiva, cioè deve garantire:
		
	\begin{itemize}
		
			
	\item ripetibilità
			
	\item confrontabilità
			
	\item confidenza
		
	\end{itemize}


		
	\subsection{Definizioni}

		
Definiziamo la \textbf{misurazione} come il processo che assegna numeri o simboli a entità del mondo reale. Risultato di una misurazione è una \textbf{misura}. Infine, definiamo una \textbf{metrica} come un insieme di regole atte all'interpretazione di un sistema di unità di misura; ogni metrica fornisce anche delle procedure per compiere misurazioni.

		
	\subsection{Misurazione del software}

		
Nella produzione di software, le metriche sono strumenti di valutazione e controllo. Cosa ci interessa misurare in questo ambito? ci interessa valutare lo stato di:
		
	\begin{itemize}
		
			
	\item processi (per valutarne la qualità);
			
	\item progetti (per effettuare stime, preventivi e consuntivi);
			
	\item prodotti (per valutarne la qualità);
			
	\item risorse (per capirne il consumo).
		
	\end{itemize}

		
Gli attributi a cui le misurazioni assegnano valori stanno in due categorie:
		
	\begin{itemize}
		
			
	\item gli attributi interni (riguardano la qualità interna) sono misurabili rispetto alle entità;
			
	\item gli attributi esterni (riguardano la qualità esterna) sono misurabili rispetto all'ambiente.
		
	\end{itemize}

		
La misurazione rischia di essere retrospettiva; ci interessa, invece, avere misure che siano il più vicino possibile al tempo di correzione: si deve misurare in modo \textbf{proattivo}, non reattivo.
		
Anche per la misurazione, ISO ha uno standard: ISO/IEC 15939. Questo standard afferma, a riguardo dei \textbf{bisogni informativi}, \textquote{the information needs are based on goals, constraints, risks, and problems which originate from the technical and mgmt process.} CMMI suggerisce di determinare tali bisogni nelle seguenti aree:
		
	\begin{itemize}
		
			
	\item gestione dei requisiti;
			
	\item progettazione e implementazione;
			
	\item verifica e validazione;
			
	\item \emph{quality assurance};
			
	\item gestione della configurazione;
			
	\item gestione di progetto;
			
	\item analisi dei rischi e analisi delle decisioni;
			
	\item allenamento.
		
	\end{itemize}

		
Ad esempio, il responsabile di progetto può essere interessato a misurare il \emph{lead time} (cioè il tempo tra un ordine di sviluppo e la relativa consegna); e il \emph{lead time} è inversamente proporzionale alla grandezza di ogni requisito, per cui un analista può essere interessato a misurare quanto sono grandi i requisiti, oltre a sapere quanto sono verificabili o quanto il prodotto soddisfa i requisiti.
		
Quando si trova un difetto, l'istinto sarebbe di correggerlo subito. Tuttavia sarebbe bene, prima, valutare il modo migliore per correggere il difetto con un buon rapporto beneficio/costi; questa è una misurazione che interessa chi si occupa della gestione dei cambiamenti (\emph{change management}).
	


		
	\newpage
	\appendix
	\section{Glossario}


		
	\begin{description}
		
			
	\item[accoppiamento] 

			Grado di dipendenza tra le varie componenti di un sistema. Inglese: \emph{coupling}.
			
	\item[algoritmo] 

			Sequenza finita di passi per la risoluzione di un problema. Inglese: \emph{algorithm}.
			
	\item[allocazione di risorse (per un progetto)] 

			Assegnare attività a ruoli e, poi, ruoli a persone.
			
	\item[ambiente di lavoro] 

			L'insieme di persone, di ruoli, di procedure e l'infrastruttura la cui qualità determina la produttività del progetto. Inglese: \emph{work environment}.
			
	\item[amministratore di progetto (profilo professionale)] 

			Chi controlla che ad ogni istante della vita del progetto le risorse (umane, materiali, economiche e strutturali) siano presenti e operanti; inoltre, gestisce la documentazione e controlla il versionamento e la configurazione. Inglese: \emph{project administrator}.
			
	\item[analisi dei requisiti] 

			Definire cosa bisogna fare. Inglese: \emph{requirements analysis}.
			
	\item[analisi dinamica] 

			Valutazione di un sistema (o di una sua componente) basata sul suo comportamento durante l'esecuzione. Inglese: \emph{dynamic analysis}.
			
	\item[analisi statica] 

			Valutazione di un sistema (o di una sua componente) basata sulla sua forma, struttura, contenuto o documentazione. Inglese: \emph{static analysis}.
			
	\item[analista (profilo professionale)] 

			Chi ha il compito di individuare, a partire dai bisogni del cliente, il problema da fornire ad un progettista; fa l'analisi dei requisiti. Inglese: \emph{analyst}.
			
	\item[application logic] 

			La parte di un software che è specifica di quel software e non è intesa per essere riusata in altri software.
			
	\item[architettura] 

			La struttura organizzativa di un sistema o componente. Inglese: \emph{architecture}.
			
	\item[attività] 

			Parte di un processo che dev'essere compiuta entro un determinato periodo di tempo. Inglese: \emph{activity}.
			
	\item[baseline] 

			Nel ciclo di vita di un progetto, punto d'arrivo tecnico dal quale non si retrocede.
			
	\item[batteria di prove] 

			Insieme di casi di prova. Inglese: \emph{test suite}.
			
	\item[best practice] 

			La prassi che, per esperienza e per studio, abbia mostrato di garantire i migliori risultati in circostanze note e specifiche.
			
	\item[bibliografia] 

			Elenco delle fonti di un documento. Inglese: \emph{bibliografy}.
			
	\item[budget] 

			Tempo e denaro a disposizione.
			
	\item[business logic] 

			La parte di un software che ha a che fare con il dominio applicativo del software; questa parte è tipicamente riusabile e quindi condivisa tra diversi software che operano nello stesso dominio.
			
	\item[caos] 

			Contrario di organizzazione. Inglese: \emph{chaos}.
			
	\item[caso d'uso] 

			Insieme di scenari che hanno in comune un obiettivo per un utente. Inglese: \emph{use case}.
			
	\item[caso di prova] 

			Terna di valori (input, output, ambiente) che specifica il comportamento che un sistema (o parte di esso) deve avere in un caso specifico. Inglese: \emph{test case}.
			
	\item[ciclo di vita (di un prodotto)] 

			Insieme degli stati che il prodotto assume, dal concepimento al ritiro. Inglese: \emph{software product life cycle}.
			
	\item[ciclo di vita dello sviluppo (di un prodotto)] 

			Parte del ciclo di vita di un prodotto che riguarda il suo sviluppo. Inglese: \emph{software development life cycle}.
			
	\item[ciclo PDCA (o ciclo di Deming)] 

			Schema iterativo di auto-miglioramento che consiste di quattro punti: Plan (individuare obiettivi di miglioramento), Do (eseguire ciò che si è pianificato), Check (verificare se ha funzionato) e Act (agire per correggersi). Inglese: \emph{PDCA cycle}.
			
	\item[CoCoMo (Constructive Cost Model)] 

			Modello per la stima dei costi di un progetto, in tempo/persona. Inglese: \emph{CoCoMo}.
			
	\item[coerenza] 

			L'esser composto da parti che non sono in disaccordo tra loro, cioè non affermano cose che si contraddicano. Inglese: \emph{consistency}.
			
	\item[coesione] 

			Grado di relazione tra parti associate di un sistema che concorrono agli stessi obiettivi. Inglese: \emph{cohesion}.
			
	\item[compito] 

			Parte di un'attività. Inglese: \emph{task}.
			
	\item[complessità ciclomatica] 

			Misura quantitativa del numero di cammini linearmente indipendenti che il codice sorgente di un programma può percorrere. Inglese: \emph{cyclomatic complexity}.
			
	\item[componente] 

			Insieme di unità funzionalmente coese; parte di un sistema. (In Java, rappresentabile da uno o più package.) Inglese: \emph{component}.
			
	\item[configuration item (CI)] 

			Parte della configurazione di un software. Inglese: \emph{configuration item}.
			
	\item[configurazione] 

			Di quali parti si compone un prodotto e il modo in cui esse stanno assieme. Inglese: \emph{configuration}.
			
	\item[controllore della qualità (profilo professionale)] 

			Funzione aziendale (e non ruolo di progetto) che accerta la qualità dei prodotti.
			
	\item[copertura del codice] 

			Percentuale di codice sorgente eseguito durante un caso di prova. Inglese: \emph{code coverage}.
			
	\item[criticità] 

			Distanza troppo breve tra attività dipendenti.
			
	\item[design pattern] 

			Soluzione progettuale generale ad un problema ricorrente.
			
	\item[diagramma dei casi d'uso] 

			Grafo orientato che mostra gli attori, i casi d'uso e le relazioni tra essi: ogni nodo è un attore o un caso d'uso; ogni arco è una comunicazione tra un attore e un caso d'uso oppure una relazione (di estensione, inclusione o generalizzazione) tra due casi d'uso o tra due attori. Inglese: \emph{use case diagram}.
			
	\item[diagramma di Gantt] 

			Diagramma che rappresenta la durata, la sequenzialità e il parallelismo delle attività di un progetto. Inglese: \emph{Gantt diagram}.
			
	\item[diagramma PERT (Project Evaluation and Review Technique)] 

			Rete che rappresenta le dipendenze temporali (e le criticità) tra attività di un progetto. Inglese: \emph{PERT diagram}.
			
	\item[diagramma WBS (Work Breakdown Structure)] 

			Diagramma che decompone in modo gerarchico le attività di un progetto in sotto-attività (coese ma non necessariamente sequenziali). Inglese: \emph{WBS diagram}.
			
	\item[disciplinato] 

			Che segue le norme (anzi, la best practice). Inglese: \emph{disciplined}.
			
	\item[documentazione] 

			Tutto ciò che documenta le attività di un progetto. Inglese: \emph{documentation}.
			
	\item[efficacia] 

			Conformità alle attese. Inglese: \emph{effectiveness}.
			
	\item[efficienza] 

			Contenimento dei consumi per raggiungere un obiettivo. Inglese: \emph{efficiency}.
			
	\item[errore] 

			Stato del sistema che, se attivato, produce un malfunzionamento. Inglese: \emph{error}.
			
	\item[fase (di un ciclo di vita)] 

			Durata temporale (che non si ripete) entro uno stato del ciclo di vita e un altro. Inglese: \emph{phase}.
			
	\item[framework] 

			Struttura di supporto su cui un software può essere organizzato e progettato.
			
	\item[gestione della qualità] 

			L'insieme dei processi che assicurano che prodotti e implementazioni di processi rispettino gli obiettivi di qualità (di un'organizzazione) e soddisfino gli stakeholder. Inglese: \emph{quality management}.
			
	\item[glossario] 

			Elenco dei significati dei termini più rilevanti di un documento. Inglese: \emph{glossary}.
			
	\item[guasto] 

			Causa di un errore. Inglese: \emph{fault}.
			
	\item[impegno] 

			 Inglese: \emph{commitment}.
			
	\item[incarico] 

			 Inglese: \emph{assignment}.
			
	\item[indice analitico] 

			Elenco ordinato delle corrispondenze tra particolari termini importanti di un documento e la loro ubicazione in esso. Inglese: \emph{index}.
			
	\item[indice generale] 

			Elenco delle parti di un documento. Inglese: \emph{table of contents}.
			
	\item[infrastruttura (di un progetto)] 

			Tutte le risorse hardware e software del progetto.
			
	\item[ingegneria] 

			L'applicazione di princìpi scientifici e matematici per scopi pratici. Inglese: \emph{engineering}.
			
	\item[ingegneria del software] 

			Applicazione di un approccio sistematico, disciplinato e quantificabile allo sviluppo, al funzionamento e al mantenimento del software. Inglese: \emph{software engineering}.
			
	\item[inspection] 

			Tecnica di analisi statica che consiste nell'eseguire una lettura mirata, alla ricerca di errori noti.
			
	\item[integrazione continua] 

			Pratica di sviluppo in cui i membri di un progetto integrano il loro lavoro frequentemente (quotidianamente) in modo automatizzato. Inglese: \emph{continuous integration}.
			
	\item[LaTeX] 

			Sistema di composizione tipografica che utilizza TeX come motore.
			
	\item[legge di Parkinson] 

			Work expands to fill the time available. Inglese: \emph{Parkinson's law}.
			
	\item[malfunzionamento] 

			Esecuzione di un software difforme dalle attese. Inglese: \emph{failure}.
			
	\item[marcatore] 

			Istruzione che un programma deve eseguire per trattare nel modo specificato dall'utente una porzione di testo specificata. Inglese: \emph{mark-up}.
			
	\item[metodo di lavoro] 

			Metodo di lavoro. Inglese: \emph{way of working}.
			
	\item[metrica] 

			L'interpretazione di un sistema di unità di misura. Inglese: \emph{metric}.
			
	\item[milestone] 

			Punto nel tempo associato ad un valore strategico.
			
	\item[misura] 

			Risultato di una misurazione.
			
	\item[misurazione quantitativa] 

			L'uso di una metrica per assegnare un valore su una scala predefinita. Inglese: \emph{quantitative measurement}.
			
	\item[modello] 

			Astrazione della realtà. Inglese: \emph{model}.
			
	\item[modulo] 

			L'elemento atomico dell'architettura di un software; tipicamente una classe o un interfaccia. Inglese: \emph{module}.
			
	\item[organizzazione] 

			Aggregato di persone [?] che agiscono in modo sistematico, disciplinato e quantificabile; contrario di caos. Inglese: \emph{organization}.
			
	\item[pianificazione] 

			Organizzare e controllare tempo, risorse e risultati. Inglese: \emph{planning}.
			
	\item[prassi] 

			Modo di fare. Inglese: \emph{practice}.
			
	\item[processo (ingegneristico)] 

			Insieme di attività correlate e coese che trasformano ingressi in uscite, consumando risorse nel farlo. Inglese: \emph{process}.
			
	\item[processo definito] 

			Specializzazione del processo standard necessaria per adattarlo ad esigenze specifiche di progetto.
			
	\item[processo di progetto] 

			Istanza di un processo definito che utilizza risorse aziendali per raggiungere obiettivi prefissati (processo calato nella realtà aziendale).
			
	\item[processo software] 

			Processo che porta ad un prodotto software. Inglese: \emph{software process}.
			
	\item[produttività] 

			Rapporto tra valore e costo. Inglese: \emph{productivity}.
			
	\item[profilo professionale] 

			Insieme di competenze (tecnologiche e metodologiche) e un'esperienza (espressa in anni e partecipazione a progetti) che fanno da requisiti per l'assunzione di un ruolo in un progetto. Inglese: \emph{professional profile}.
			
	\item[progettazione] 

			Definizione dell'architettura, delle componenti, delle interfacce e delle altre caratteristiche di un sistema o componente. Inglese: \emph{design}.
			
	\item[progettazione architetturale] 

			Definizione delle componenti e di come esse sono organizzate in un sistema. Inglese: \emph{architectural design}.
			
	\item[progettazione di dettaglio] 

			Definizione del comportamento delle componenti di un sistema, con un livello di dettaglio tale per cui le componenti possano essere implementate. Inglese: \emph{detailed design}.
			
	\item[progettista (profilo professionale)] 

			Chi sintetizza una soluzione a partire dalle specifiche di un problema già analizzato. Inglese: \emph{designer}.
			
	\item[progetto] 

			Insieme di compiti da svolgere in modo collaborativo a fronte di un incarico (che diventa poi un impegno). Inglese: \emph{project}.
			
	\item[programmatore (profilo professionale)] 

			Chi implementa una parte della soluzione dei progettisti. Inglese: \emph{programmer}.
			
	\item[protocollo] 

			Accordo di interfacce. Inglese: \emph{protocol}.
			
	\item[qualifica] 

			Verifica e validazione ("V\&{}V"), cioè quei processi che assicurano la qualità di un prodotto durante il suo ciclo di vita.
			
	\item[qualità] 

			L'insieme delle caratteristiche di un'entità che ne determinano la capacità di soddisfare esigenze espresse e implicite. Inglese: \emph{quality}.
			
	\item[quality assurance] 

			Insieme di attività che valutano i processi con i quali un prodotto viene sviluppato.
			
	\item[quantificabile] 

			Esprimibile in modo quantitativo. Inglese: \emph{quantifiable}.
			
	\item[raccomandazione] 

			Norma di progetto suggerita, non sottoposta a verifica. Inglese: \emph{recommendation}.
			
	\item[ramo (di un repository)] 

			Insieme di versioni di file sorgente in evoluzione. Inglese: \emph{branch}.
			
	\item[regola] 

			Norma di progetto sottoposta a verifica. Inglese: \emph{rule}.
			
	\item[rendimento decrescente, legge del] 

			Man mano che si aumenta lo sforzo, il rendimento cresce inizialmente ma poi diminuisce sempre più. Inglese: \emph{diminishing returns}.
			
	\item[repository] 

			Base di dati centralizzata nella quale risiedono, individualmente, tutti i CI di ogni baseline nella loro storia completa.
			
	\item[requisito] 

			Bisogno da soddisfare o vincolo da rispettare. Inglese: \emph{requirement}.
			
	\item[requisito di processo] 

			Vincolo sullo sviluppo del prodotto.
			
	\item[requisito di prodotto] 

			Bisogno o vincolo sul prodotto da sviluppare.
			
	\item[requisito di sistema] 

			Definizione formale e dettagliata di una funzione del sistema. Inglese: \emph{system requirement}.
			
	\item[requisito funzionale] 

			(di un prodotto software) servizio che il prodotto deve fornire. Inglese: \emph{functional requirement}.
			
	\item[requisito non funzionale] 

			(di un prodotto software) vincolo su uno o più servizi che il prodotto fornisce. Inglese: \emph{non-functional requirement}.
			
	\item[requisito utente] 

			Richiesta generale, ad alto livello. Inglese: \emph{user requirement}.
			
	\item[responsabile di progetto (profilo professionale)] 

			Chi pianifica il progetto, assegna le persone ai ruoli giusti e rappresenta il progetto presso il fornitore e il committente. Inglese: \emph{project manager}.
			
	\item[rete] 

			Grafo orientato. Inglese: \emph{network}.
			
	\item[revisione esterna] 

			Ispezione ufficiale di un prodotto condotta da un'organizzazione indipendente da chi ha sviluppato il prodotto. Inglese: \emph{audit}.
			
	\item[revisione interna] 

			Ispezione di un prodotto interna all'organizzazione che lo sviluppa. Inglese: \emph{joint review}.
			
	\item[rischio] 

			Opposto di opportunità. Inglese: \emph{risk}.
			
	\item[ritiro (di un prodotto)] 

			Momento in cui il prodotto cessa di essere seguito dai suoi creatori. Inglese: \emph{retirement}.
			
	\item[ruolo] 

			Funzione aziendale assegnata a progetto; identifica capacità e compiti. Inglese: \emph{role}.
			
	\item[scenario] 

			Sequenza di passi che descrive un esempio di interazione con un sistema.
			
	\item[sistema] 

			Insieme di componenti organizzati per compiere una o più funzioni. Inglese: \emph{system}.
			
	\item[sistematico] 

			Che abbraccia un metodo. Inglese: \emph{systematic}.
			
	\item[slack time] 

			Quantità di tempo tra la data minima a partire da cui un evento può accadere e la data massima oltre la quale esso ritarda gli eventi successivi.
			
	\item[sommario] 

			Breve riassunto del contenuto di un documento. Inglese: \emph{abstract}.
			
	\item[SQL (Structured Query Language] 

			Linguaggio di programmazione dichiarativo basato sull'algebra relazionale che serve a creare, manipolare e interrogare basi di dati relazionali. Inglese: \emph{SQL}.
			
	\item[stakeholder] 

			Persona a vario titolo coinvolta nel ciclo di vita di un software che ha influenza sul prodotto o sul processo.
			
	\item[standard di processo] 

			Riferimento di base generico usato come stile comune per lo svolgimento delle funzioni aziendali, pensato per una collettività di casi afferenti ad un certo dominio applicativo. Inglese: \emph{process standard}.
			
	\item[strumento] 

			Insieme di concetti e di metodi, con delle tecnologie di supporto. Inglese: \emph{tool}.
			
	\item[tecnica] 

			Ricetta applicata agli strumenti disponibili; modo con cui si usa uno strumento. Inglese: \emph{technique}.
			
	\item[tecnologia] 

			Strumento sul quale si opera. Inglese: \emph{technology}.
			
	\item[test] 

			Attività di analisi dinamica che osserva i risultati dell'esecuzione di un sistema (o parte di esso) sotto determinate condizioni.
			
	\item[test di integrazione] 

			Test che verifica la correttezza dell'integrazione di un insieme di unità in una componente del sistema in esame. Inglese: \emph{integration test}.
			
	\item[test di sistema] 

			Test che verifica la copertura dei requisiti da parte del sistema in esame. Inglese: \emph{system test}.
			
	\item[test di unità] 

			Test che verifica la correttezza di una singola unità del sistema in esame. Inglese: \emph{unit test}.
			
	\item[test di validazione] 

			Test che verifica il soddisfacimento del capitolato d'appalto da parte del sistema in esame. Inglese: \emph{validation test}.
			
	\item[test funzionale] 

			Test di unità che analizza la logica interna del codice di un'unità. Inglese: \emph{functional test}.
			
	\item[test strutturale] 

			Test di unità che analizza soltanto il comportamento dell'unità e non la sua logica interna. Inglese: \emph{structural test}.
			
	\item[TeX] 

			Linguaggio formale di composizione tipografica.
			
	\item[UML (Unified Modelling Language)] 

			Famiglia di notazioni grafiche che si basano su un singolo meta-modello e servono a supportare la descrizione e il progetto dei sistemi software. Inglese: \emph{UML}.
			
	\item[unità] 

			Insieme coeso di moduli, appaltabili in realizzazione a un singolo programmatore; non ha sempre un corrispondente diretto in un linguaggio di programmazione. È anche la più piccola quantità di software che conviene verificare da sola. Inglese: \emph{unit}.
			
	\item[validazione] 

			La garanzia che un prodotto soddisfi i requisiti da cui è nato. Inglese: \emph{validation}.
			
	\item[valutazione] 

			Verifica quantificata. Inglese: \emph{evaluation}.
			
	\item[verifica] 

			Valutare se un prodotto soddisfa requisiti, regole o altre condizioni necessarie. Inglese: \emph{verification}.
			
	\item[verificatore (profilo professionale)] 

			Chi verifica il lavoro dei programmatori.
			
	\item[versione (di un CI)] 

			Istanza identificata di un CI nel tempo. Inglese: \emph{version}.
			
	\item[walkthrough] 

			Tecnica di analisi statica che consiste nell'eseguire una lettura critica, ad ampio spettro, senza l'assunzione di presupposti.
		
	\end{description}

	


\nocite{*}
\begin{thebibliography}{9}
	\bibitem{sommerville}
		Ian Sommerville,
		\emph{Software Engineering} (9th ed.),
		Addison-Wesley, 2011.
	\bibitem{swebok}
		IEEE,
		\emph{Guide to the Software Engineering Body of Knowledge} v3.0,
		ed. P. Bourque \and R. Fairley, 2014.
	\bibitem{tullio}
		Tullio Vardanega,
		Lucidi per le lezioni dell'A.A. 2016-2017.
	\bibitem{cardin}
		Riccardo Cardin,
		Lucidi per le lezioni dell'A.A. 2016-2017.
	\bibitem{anon_is}
		Anonimo,
		\emph{Riassunto IS},
		reperito su MEGA.
	\bibitem{distilled}
		Martin Fowler,
		\emph{UML Distilled},
		reperito sul web.
\end{thebibliography}

\end{document}
